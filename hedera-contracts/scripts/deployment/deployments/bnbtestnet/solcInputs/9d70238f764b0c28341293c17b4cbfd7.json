{
  "language": "Solidity",
  "sources": {
    "contracts/Equity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./utils/MathUtil.sol\";\nimport \"./interface/IReserve.sol\";\nimport \"./interface/IOracleFreeDollar.sol\";\nimport \"./interface/IERC677Receiver.sol\";\nimport \"./utils/ERC20PermitLight.sol\";\n\n/**\n * @title Equity\n * @notice If the OracleFreeDollar system was a bank, this contract would represent the equity on its balance sheet.\n * Like with a corporation, the owners of the equity capital are the shareholders, or in this case the holders\n * of OracleFreeDollar Pool Shares (OFDPS) tokens. Anyone can mint additional OFDPS tokens by adding OracleFreeDollars to the\n * reserve pool. Also, OFDPS tokens can be redeemed for OracleFreeDollars again after a minimum holding period.\n * Furthermore, the OFDPS shares come with some voting power. Anyone that held at least 3% of the holding-period-\n * weighted reserve pool shares gains veto power and can veto new proposals.\n */\ncontract Equity is ERC20PermitLight, MathUtil, IReserve {\n    /**\n     * The VALUATION_FACTOR determines the market cap of the reserve pool shares relative to the equity reserves.\n     * The following always holds: Market Cap = Valuation Factor * Equity Reserve = Price * Supply\n     *\n     * In the absence of profits and losses, the variables grow as follows when OFDPS tokens are minted:\n     *\n     * |   Reserve     |   Market Cap  |     Price     |     Supply   |\n     * |          1000 |          3000 |             3 |         1000 |\n     * |       1000000 |       3000000 |           300 |        10000 |\n     * |    1000000000 |    3000000000 |         30000 |       100000 |\n     * | 1000000000000 | 3000000000000 |       3000000 |      1000000 |\n     *\n     * I.e., the supply is proporational to the cubic root of the reserve and the price is proportional to the\n     * squared cubic root. When profits accumulate or losses materialize, the reserve, the market cap,\n     * and the price are adjusted proportionally, with the supply staying constant. In the absence of an extreme\n     * inflation of the American Dollar, it is unlikely that there will ever be more than ten million OFDPS.\n     */\n    uint32 public constant VALUATION_FACTOR = 3;\n\n    uint256 private constant MINIMUM_EQUITY = 1000 * ONE_DEC18;\n\n    /**\n     * @notice The quorum in basis points. 100 is 1%.\n     */\n    uint32 private constant QUORUM = 200;\n\n    /**\n     * @notice The number of digits to store the average holding time of share tokens.\n     */\n    uint8 private constant TIME_RESOLUTION_BITS = 20;\n\n    /**\n     * @notice The minimum holding duration. You are not allowed to redeem your pool shares if you held them\n     * for less than the minimum holding duration at average. For example, if you have two pool shares on your\n     * address, one acquired 5 days ago and one acquired 105 days ago, you cannot redeem them as the average\n     * holding duration of your shares is only 55 days < 90 days.\n     */\n    uint256 public constant MIN_HOLDING_DURATION = 90 days << TIME_RESOLUTION_BITS; // Set to 5 for local testing\n\n    IOracleFreeDollar public immutable ofd;\n\n    /**\n     * @dev To track the total number of votes we need to know the number of votes at the anchor time and when the\n     * anchor time was. This is (hopefully) stored in one 256 bit slot, with the anchor time taking 64 Bits and\n     * the total vote count 192 Bits. Given the sub-second resolution of 20 Bits, the implicit assumption is\n     * that the timestamp can always be stored in 44 Bits (i.e. it does not exceed half a million years). Further,\n     * given 18 decimals (about 60 Bits), this implies that the total supply cannot exceed\n     *   192 - 60 - 44 - 20 = 68 Bits\n     * Here, we are also save, as 68 Bits would imply more than a trillion outstanding shares. In fact,\n     * a limit of about 2**36 shares (that's about 2**96 Bits when taking into account the decimals) is imposed\n     * when minting. This means that the maximum supply is billions shares, which is could only be reached in\n     * a scenario with hyper inflation, in which case the stablecoin is worthless anyway.\n     */\n    uint192 private totalVotesAtAnchor; // Total number of votes at the anchor time, see comment on the um\n    uint64 private totalVotesAnchorTime; // 44 Bit for the time stamp, 20 Bit sub-second time resolution\n\n    /**\n     * @notice Keeping track on who delegated votes to whom.\n     * Note that delegation does not mean you cannot vote / veto any more, it just means that the delegate can\n     * benefit from your votes when invoking a veto. Circular delegations are valid, do not help when voting.\n     */\n    mapping(address owner => address delegate) public delegates;\n\n    /**\n     * @notice A time stamp in the past such that: votes = balance * (time passed since anchor was set)\n     */\n    mapping(address owner => uint64 timestamp) private voteAnchor; // 44 bits for time stamp, 20 subsecond resolution\n\n    event Delegation(address indexed from, address indexed to); // indicates a delegation\n    event Trade(address who, int amount, uint totPrice, uint newprice); // amount pos or neg for mint or redemption\n\n    constructor(IOracleFreeDollar ofd_) ERC20(18) {\n        ofd = ofd_;\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"OracleFreeDollar Pool Share\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"OFDPS\";\n    }\n\n    /**\n     * @notice Returns the price of one OFDPS in OFD with 18 decimals precision.\n     */\n    function price() public view returns (uint256) {\n        uint256 equity = ofd.equity();\n        if (equity == 0 || totalSupply() == 0) {\n            return ONE_DEC18; // initial price is 1000 OFD for the first 1000 OFDPS\n        } else {\n            return (VALUATION_FACTOR * ofd.equity() * ONE_DEC18) / totalSupply();\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n        if (amount > 0) {\n            // No need to adjust the sender votes. When they send out 10% of their shares, they also lose 10% of\n            // their votes so everything falls nicely into place. Recipient votes should stay the same, but grow\n            // faster in the future, requiring an adjustment of the anchor.\n            uint256 roundingLoss = _adjustRecipientVoteAnchor(to, amount);\n            // The total also must be adjusted and kept accurate by taking into account the rounding error.\n            _adjustTotalVotes(from, amount, roundingLoss);\n        }\n    }\n\n    /**\n     * @notice Returns whether the given address is allowed to redeem OFDPS, which is the\n     * case after their average holding duration is larger than the required minimum.\n     */\n    function canRedeem(address owner) public view returns (bool) {\n        return _anchorTime() - voteAnchor[owner] >= MIN_HOLDING_DURATION;\n    }\n\n    /**\n     * @notice Decrease the total votes anchor when tokens lose their voting power due to being moved\n     * @param from      sender\n     * @param amount    amount to be sent\n     */\n    function _adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\n        uint64 time = _anchorTime();\n        uint256 lostVotes = from == address(0x0) ? 0 : (time - voteAnchor[from]) * amount;\n        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\n        totalVotesAnchorTime = time;\n    }\n\n    /**\n     * @notice the vote anchor of the recipient is moved forward such that the number of calculated\n     * votes does not change despite the higher balance.\n     * @param to        receiver address\n     * @param amount    amount to be received\n     * @return the number of votes lost due to rounding errors\n     */\n    function _adjustRecipientVoteAnchor(address to, uint256 amount) internal returns (uint256) {\n        if (to != address(0x0)) {\n            uint256 recipientVotes = votes(to); // for example 21 if 7 shares were held for 3 seconds\n            uint256 newbalance = balanceOf(to) + amount; // for example 11 if 4 shares are added\n            // new example anchor is only 21 / 11 = 1 second in the past\n            voteAnchor[to] = uint64(_anchorTime() - recipientVotes / newbalance);\n            return recipientVotes % newbalance; // we have lost 21 % 11 = 10 votes\n        } else {\n            // optimization for burn, vote anchor of null address does not matter\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Time stamp with some additional bits for higher resolution.\n     */\n    function _anchorTime() internal view returns (uint64) {\n        return uint64(block.timestamp << TIME_RESOLUTION_BITS);\n    }\n\n    /**\n     * @notice The relative voting power of the address.\n     * @return A percentage with 1e18 being 100%\n     */\n    function relativeVotes(address holder) external view returns (uint256) {\n        return (ONE_DEC18 * votes(holder)) / totalVotes();\n    }\n\n    /**\n     * @notice The votes of the holder, excluding votes from delegates.\n     */\n    function votes(address holder) public view returns (uint256) {\n        return balanceOf(holder) * (_anchorTime() - voteAnchor[holder]);\n    }\n\n    /**\n     * @notice How long the holder already held onto their average OFDPS in seconds.\n     */\n    function holdingDuration(address holder) public view returns (uint256) {\n        return (_anchorTime() - voteAnchor[holder]) >> TIME_RESOLUTION_BITS;\n    }\n\n    /**\n     * @notice Total number of votes in the system.\n     */\n    function totalVotes() public view returns (uint256) {\n        return totalVotesAtAnchor + totalSupply() * (_anchorTime() - totalVotesAnchorTime);\n    }\n\n    /**\n     * @notice The number of votes the sender commands when taking the support of the helpers into account.\n     * @param sender    The address whose total voting power is of interest\n     * @param helpers   An incrementally sorted list of helpers without duplicates and without the sender.\n     *                  The call fails if the list contains an address that does not delegate to sender.\n     *                  For indirect delegates, i.e. a -> b -> c, both a and b must be included for both to count.\n     * @return          The total number of votes of sender at the current point in time.\n     */\n    function votesDelegated(address sender, address[] calldata helpers) public view returns (uint256) {\n        uint256 _votes = votes(sender);\n        require(_checkDuplicatesAndSorted(helpers));\n        for (uint i = 0; i < helpers.length; i++) {\n            address current = helpers[i];\n            require(current != sender);\n            require(_canVoteFor(sender, current));\n            _votes += votes(current);\n        }\n        return _votes;\n    }\n\n    function _checkDuplicatesAndSorted(address[] calldata helpers) internal pure returns (bool ok) {\n        if (helpers.length <= 1) {\n            return true;\n        } else {\n            address prevAddress = helpers[0];\n            for (uint i = 1; i < helpers.length; i++) {\n                if (helpers[i] <= prevAddress) {\n                    return false;\n                }\n                prevAddress = helpers[i];\n            }\n            return true;\n        }\n    }\n\n    /**\n     * @notice Checks whether the sender address is qualified given a list of helpers that delegated their votes\n     * directly or indirectly to the sender. It is the responsiblity of the caller to figure out whether\n     * helpes are necessary and to identify them by scanning the blockchain for Delegation events.\n     */\n    function checkQualified(address sender, address[] calldata helpers) public view override {\n        uint256 _votes = votesDelegated(sender, helpers);\n        if (_votes * 10000 < QUORUM * totalVotes()) revert NotQualified();\n    }\n\n    error NotQualified();\n\n    /**\n     * @notice Increases the voting power of the delegate by your number of votes without taking away any voting power\n     * from the sender.\n     */\n    function delegateVoteTo(address delegate) external {\n        delegates[msg.sender] = delegate;\n        emit Delegation(msg.sender, delegate);\n    }\n\n    function _canVoteFor(address delegate, address owner) internal view returns (bool) {\n        if (owner == delegate) {\n            return true;\n        } else if (owner == address(0x0)) {\n            return false;\n        } else {\n            return _canVoteFor(delegate, delegates[owner]);\n        }\n    }\n\n    /**\n     * @notice Since quorum is rather low, it is important to have a way to prevent malicious minority holders\n     * from blocking the whole system. This method provides a way for the good guys to team up and destroy\n     * the bad guy's votes (at the cost of also reducing their own votes). This mechanism potentially\n     * gives full control over the system to whoever has 51% of the votes.\n     *\n     * Since this is a rather aggressive measure, delegation is not supported. Every holder must call this\n     * method on their own.\n     * @param targets   The target addresses to remove votes from\n     * @param votesToDestroy    The maximum number of votes the caller is willing to sacrifice\n     */\n    function kamikaze(address[] calldata targets, uint256 votesToDestroy) external {\n        uint256 budget = _reduceVotes(msg.sender, votesToDestroy);\n        uint256 destroyedVotes = 0;\n        for (uint256 i = 0; i < targets.length && destroyedVotes < budget; i++) {\n            destroyedVotes += _reduceVotes(targets[i], budget - destroyedVotes);\n        }\n        require(destroyedVotes > 0); // sanity check\n        totalVotesAtAnchor = uint192(totalVotes() - destroyedVotes - budget);\n        totalVotesAnchorTime = _anchorTime();\n    }\n\n    function _reduceVotes(address target, uint256 amount) internal returns (uint256) {\n        uint256 votesBefore = votes(target);\n        if (amount >= votesBefore) {\n            amount = votesBefore;\n            voteAnchor[target] = _anchorTime();\n            return votesBefore;\n        } else {\n            voteAnchor[target] = uint64(_anchorTime() - (votesBefore - amount) / balanceOf(target));\n            return votesBefore - votes(target);\n        }\n    }\n\n    /**\n     * @notice Call this method to obtain newly minted pool shares in exchange for OracleFreeDollars.\n     * No allowance required (i.e. it is hardcoded in the OracleFreeDollar token contract).\n     * Make sure to invest at least 10e-12 * market cap to avoid rounding losses.\n     *\n     * @dev If equity is close to zero or negative, you need to send enough OFD to bring equity back to 1000 OFD.\n     *\n     * @param amount            OracleFreeDollars to invest\n     * @param expectedShares    Minimum amount of expected shares for frontrunning protection\n     */\n    function invest(uint256 amount, uint256 expectedShares) external returns (uint256) {\n        ofd.transferFrom(msg.sender, address(this), amount);\n        uint256 equity = ofd.equity();\n        require(equity >= MINIMUM_EQUITY, \"insuf equity\"); // ensures that the initial deposit is at least 1000 OFD\n\n        uint256 shares = _calculateShares(equity <= amount ? 0 : equity - amount, amount);\n        require(shares >= expectedShares);\n        _mint(msg.sender, shares);\n        emit Trade(msg.sender, int(shares), amount, price());\n\n        // limit the total supply to a reasonable amount to guard against overflows with price and vote calculations\n        // the 36 bits are 68 bits for magnitude and 60 bits for precision, as calculated in an above comment\n        require(totalSupply() <= type(uint96).max, \"total supply exceeded\");\n        return shares;\n    }\n\n    /**\n     * @notice Calculate shares received when investing OracleFreeDollars\n     * @param investment    OFD to be invested\n     * @return shares to be received in return\n     */\n    function calculateShares(uint256 investment) external view returns (uint256) {\n        return _calculateShares(ofd.equity(), investment);\n    }\n\n    function _calculateShares(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 investmentExFees = (investment * 997) / 1000; // remove 0.3% fee\n        // Assign 1000 OFDPS for the initial deposit, calculate the amount otherwise\n        uint256 newTotalShares = capitalBefore < MINIMUM_EQUITY || totalShares == 0\n            ? totalShares + 1000 * ONE_DEC18\n            : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investmentExFees, capitalBefore)));\n        return newTotalShares - totalShares;\n    }\n\n    /**\n     * @notice Redeem the given amount of shares owned by the sender and transfer the proceeds to the target.\n     * @return The amount of OFD transferred to the target\n     */\n    function redeem(address target, uint256 shares) external returns (uint256) {\n        return _redeemFrom(msg.sender, target, shares);\n    }\n\n    /**\n     * @notice Like redeem(...), but with an extra parameter to protect against frontrunning.\n     * @param expectedProceeds  The minimum acceptable redemption proceeds.\n     */\n    function redeemExpected(address target, uint256 shares, uint256 expectedProceeds) external returns (uint256) {\n        uint256 proceeds = _redeemFrom(msg.sender, target, shares);\n        require(proceeds >= expectedProceeds);\n        return proceeds;\n    }\n\n    /**\n     * @notice Redeem OFDPS based on an allowance from the owner to the caller.\n     * See also redeemExpected(...).\n     */\n    function redeemFrom(\n        address owner,\n        address target,\n        uint256 shares,\n        uint256 expectedProceeds\n    ) external returns (uint256) {\n        _useAllowance(owner, msg.sender, shares);\n        uint256 proceeds = _redeemFrom(owner, target, shares);\n        require(proceeds >= expectedProceeds);\n        return proceeds;\n    }\n\n    function _redeemFrom(address owner, address target, uint256 shares) internal returns (uint256) {\n        require(canRedeem(owner));\n        uint256 proceeds = calculateProceeds(shares);\n        _burn(owner, shares);\n        ofd.transfer(target, proceeds);\n        emit Trade(owner, -int(shares), proceeds, price());\n        return proceeds;\n    }\n\n    /**\n     * @notice Calculate OFD received when depositing shares\n     * @param shares number of shares we want to exchange for OFD,\n     *               in dec18 format\n     * @return amount of OFD received for the shares\n     */\n    function calculateProceeds(uint256 shares) public view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n        uint256 capital = ofd.equity();\n        uint256 reductionAfterFees = (shares * 997) / 1000;\n        uint256 newCapital = _mulD18(capital, _power3(_divD18(totalShares - reductionAfterFees, totalShares)));\n        return capital - newCapital;\n    }\n\n    /**\n     * @notice If there is less than 1000 OFD in equity left (maybe even negative), the system is at risk\n     * and we should allow qualified OFDPS holders to restructure the system.\n     *\n     * Example: there was a devastating loss and equity stands at -1'000'000. Most shareholders have lost hope in the\n     * OracleFreeDollar system except for a group of small OFDPS holders who still believes in it and is willing to provide\n     * 2'000'000 OFD to save it. These brave souls are essentially donating 1'000'000 to the minter reserve and it\n     * would be wrong to force them to share the other million with the passive OFDPS holders. Instead, they will get\n     * the possibility to bootstrap the system again owning 100% of all OFDPS shares.\n     *\n     * @param helpers          A list of addresses that delegate to the caller in incremental order\n     * @param addressesToWipe  A list of addresses whose OFDPS will be burned to zero\n     */\n    function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) external {\n        require(ofd.equity() < MINIMUM_EQUITY);\n        checkQualified(msg.sender, helpers);\n        for (uint256 i = 0; i < addressesToWipe.length; i++) {\n            address current = addressesToWipe[i];\n            _burn(current, balanceOf(current));\n        }\n    }\n}\n"
    },
    "contracts/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n *\n * Copyright (c) 2016-2019 zOS Global Limited\n *\n */\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns always true. Throws error on failure.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value can change when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns always true. Throws error on failure.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interface/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC677Receiver {\n\n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\n\n}\n"
    },
    "contracts/interface/ILeadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ILeadrate {\n   function currentRatePPM() external view returns (uint24);\n   function currentTicks() external view returns (uint64);\n}"
    },
    "contracts/interface/IOracleFreeDollar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\n\ninterface IOracleFreeDollar is IERC20 {\n    function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) external;\n\n    function registerPosition(address position) external;\n\n    function denyMinter(address minter, address[] calldata helpers, string calldata message) external;\n\n    function reserve() external view returns (IReserve);\n\n    function minterReserve() external view returns (uint256);\n\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) external view returns (uint256);\n\n    function calculateFreedAmount(uint256 amountExcludingReserve, uint32 reservePPM) external view returns (uint256);\n\n    function equity() external view returns (uint256);\n\n    function isMinter(address minter) external view returns (bool);\n\n    function getPositionParent(address position) external view returns (address);\n\n    function mint(address target, uint256 amount) external;\n\n    function mintWithReserve(address target, uint256 amount, uint32 reservePPM, uint32 feePPM) external;\n\n    function burnFrom(address target, uint256 amount) external;\n\n    function burnWithoutReserve(uint256 amountIncludingReserve, uint32 reservePPM) external;\n\n    function burnFromWithReserve(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external returns (uint256);\n\n    function burnWithReserve(uint256 amountExcludingReserve, uint32 reservePPM) external returns (uint256);\n\n    function coverLoss(address source, uint256 amount) external;\n\n    function collectProfits(address source, uint256 _amount) external;\n}\n"
    },
    "contracts/interface/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\ninterface IPosition {\n\n    function initialize(address parent, uint40 _expiration) external;\n\n    function hub() external view returns(address);\n\n    function original() external view returns (address);\n\n    function collateral() external view returns (IERC20);\n\n    function minimumCollateral() external view returns (uint256);\n\n    function challengePeriod() external view returns (uint40);\n\n    function expiration() external view returns (uint40);\n\n    function price() external view returns (uint256);\n\n    function deny(address[] calldata helpers, string calldata message) external;\n\n    function mint(address target, uint256 amount) external;\n\n    function repay(uint256 amount) external returns (uint256);\n\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) external;\n\n    function minted() external view returns (uint256);\n\n    function availableForMinting() external view returns (uint256);\n\n    function reserveContribution() external view returns (uint24);\n\n    function withdrawCollateral(address target, uint256 amount) external;\n\n    function getUsableMint(uint256 totalMint, bool beforeFees) external view returns (uint256);\n\n    function getMintAmount(uint256 usableMint) external view returns (uint256);\n\n    function challengeData() external view returns (uint256 liqPrice, uint40 phase);\n\n    function notifyChallengeStarted(uint256 size) external;\n\n    function notifyChallengeAverted(uint256 size) external;\n\n    function notifyChallengeSucceeded(address _bidder, uint256 _size) external returns (address, uint256, uint256, uint32);\n\n    function forceSale(address buyer, uint256 collAmount, uint256 proceeds) external;\n\n}\n"
    },
    "contracts/interface/IPositionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPositionFactory {\n    function createNewPosition(\n        address _owner,\n        address _ofd,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint40 _initPeriod,\n        uint40 _duration,\n        uint40 _challengePeriod,\n        uint24 _riskPremiumPPM,\n        uint256 _liqPrice,\n        uint24 _reserve\n    ) external returns (address);\n\n    function clonePosition(address _parent) external returns (address);\n}\n"
    },
    "contracts/interface/IReserve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\ninterface IReserve is IERC20 {\n   function invest(uint256 amount, uint256 expected) external returns (uint256);\n   function checkQualified(address sender, address[] calldata helpers) external view;\n}"
    },
    "contracts/Leadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './interface/IERC20.sol';\nimport './interface/IOracleFreeDollar.sol';\nimport './interface/IReserve.sol';\n\n/**\n * @title Leadrate (attempt at translating the nicely concise German term 'Leitzins')\n *\n * A module that can provide other modules with the lead interest rate for the system.\n *\n **/\ncontract Leadrate {\n\n\tIReserve public immutable equity;\n\n\t// the following five variables are less than 256 bit so they should be stored\n\t// in the same slot, making them cheap to access together, right?\n\n\tuint24 public currentRatePPM; // 24 bit allows rates of up to 1670% per year\n\tuint24 public nextRatePPM;\n\tuint40 public nextChange;\n\n\tuint40 private anchorTime; // 40 bits for time in seconds spans up to 1000 human generations\n\tuint64 private ticksAnchor; // in bips * seconds, uint88 allows up to\n\n\tevent RateProposed(address who, uint24 nextRate, uint40 nextChange);\n\tevent RateChanged(uint24 newRate);\n\n\terror NoPendingChange();\n\terror ChangeNotReady();\n\n\tconstructor(IReserve equity_, uint24 initialRatePPM) {\n\t\tequity = equity_;\n\t\tnextRatePPM = initialRatePPM;\n\t\tcurrentRatePPM = initialRatePPM;\n\t\tnextChange = uint40(block.timestamp);\n\t\tanchorTime = nextChange;\n\t\tticksAnchor = 0;\n\t\temit RateChanged(initialRatePPM); // emit for init indexing, if wanted\n\t}\n\n\t/**\n     * Proposes a new interest rate that will automatically be applied after seven days.\n     * To cancel a proposal, just overwrite it with a new one proposing the current rate.\n     */\n\tfunction proposeChange(uint24 newRatePPM_, address[] calldata helpers) external {\n\t\tequity.checkQualified(msg.sender, helpers);\n\t\tnextRatePPM = newRatePPM_;\n\t\tnextChange = uint40(block.timestamp + 7 days);\n\t\temit RateProposed(msg.sender, nextRatePPM, nextChange);\n\t}\n\n\t/**\n     * Setting a previously proposed interest rate change into force.\n     */\n\tfunction applyChange() external {\n\t\tif (currentRatePPM == nextRatePPM) revert NoPendingChange();\n\t\tuint40 timeNow = uint40(block.timestamp);\n\t\tif (timeNow < nextChange) revert ChangeNotReady();\n\t\tticksAnchor += (timeNow - anchorTime) * currentRatePPM;\n\t\tanchorTime = timeNow;\n\t\tcurrentRatePPM = nextRatePPM;\n\t\temit RateChanged(currentRatePPM);\n\t}\n\n\t/**\n     * Total accumulated 'interest ticks' since this contract was deployed.\n     * One 'tick' is a ppm-second, so one months of 12% annual interest is\n     *   120000*30*24*3600 = 311040000000 ticks.\n     * Two months of 6% annual interest would result in the same number of\n     * ticks. For simplicity, this is linear, so there is no \"interest on interest\".\n     */\n\tfunction currentTicks() public view returns (uint64) {\n\t\treturn ticks(block.timestamp);\n\t}\n\n\tfunction ticks(uint256 timestamp) public view returns (uint64) {\n\t\treturn ticksAnchor + (uint64(timestamp) - anchorTime) * currentRatePPM;\n\t}\n\n}\n"
    },
    "contracts/MintingHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './interface/IERC20.sol';\nimport './interface/ILeadrate.sol';\nimport './interface/IOracleFreeDollar.sol';\nimport './interface/IPosition.sol';\nimport './interface/IPositionFactory.sol';\nimport './interface/IReserve.sol';\n\nimport './PositionRoller.sol';\nimport './utils/Ownable.sol';\n\n/**\n * @title Minting Hub\n * @notice The central hub for creating, cloning and challenging collateralized OracleFreeDollar positions.\n * @dev Only one instance of this contract is required, whereas every new position comes with a new position\n * contract. Pending challenges are stored as structs in an array.\n */\ncontract MintingHub {\n\t/**\n     * @notice Irrevocable fee in OFD when proposing a new position (but not when cloning an existing one).\n     */\n\tuint256 public constant OPENING_FEE = 1000 * 10 ** 18;\n\n\t/**\n     * @notice The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\n     */\n\tuint256 public constant CHALLENGER_REWARD = 20000; // 2%\n\tuint256 public constant EXPIRED_PRICE_FACTOR = 10;\n\n\tIPositionFactory private immutable POSITION_FACTORY; // position contract to clone\n\n\tIOracleFreeDollar public immutable ofd; // currency\n\tPositionRoller public immutable roller; // helper to roll positions\n\tILeadrate public immutable rate; // to determine the interest rate\n\n\tChallenge[] public challenges; // list of open challenges\n\n\t/**\n     * @notice Map to remember pending postponed collateral returns.\n     * @dev It maps collateral => beneficiary => amount.\n     */\n\tmapping(address collateral => mapping(address owner => uint256 amount)) public pendingReturns;\n\n\tstruct Challenge {\n\t\taddress challenger; // the address from which the challenge was initiated\n\t\tuint40 start; // the start of the challenge\n\t\tIPosition position; // the position that was challenged\n\t\tuint256 size; // how much collateral the challenger provided\n\t}\n\n\tevent PositionOpened(address indexed owner, address indexed position, address original, address collateral);\n\tevent ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\n\tevent ChallengeAverted(address indexed position, uint256 number, uint256 size);\n\tevent ChallengeSucceeded(\n\t\taddress indexed position,\n\t\tuint256 number,\n\t\tuint256 bid,\n\t\tuint256 acquiredCollateral,\n\t\tuint256 challengeSize\n\t);\n\tevent PostPonedReturn(address collateral, address indexed beneficiary, uint256 amount);\n\tevent ForcedSale(address pos, uint256 amount, uint256 priceE36MinusDecimals);\n\n\terror UnexpectedPrice();\n\terror InvalidPos();\n\terror IncompatibleCollateral();\n\terror InsufficientCollateral();\n\n\tmodifier validPos(address position) {\n\t\tif (ofd.getPositionParent(position) != address(this)) revert InvalidPos();\n\t\t_;\n\t}\n\n\tconstructor(address _ofd, address _leadrate, address _roller, address _factory) {\n\t\tofd = IOracleFreeDollar(_ofd);\n\t\trate = ILeadrate(_leadrate);\n\t\tPOSITION_FACTORY = IPositionFactory(_factory);\n\t\troller = PositionRoller(_roller);\n\t}\n\n\t/**\n     * @notice Open a collateralized loan position. See also https://oracle-free-dollar.gitbook.io/ofd/collateralised-minting/opening-new-position .\n     * @dev For a successful call, you must set an allowance for the collateral token, allowing\n     * the minting hub to transfer the initial collateral amount to the newly created position and to\n     * withdraw the fees.\n     *\n     * @param _collateralAddress        address of collateral token\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\n     * @param _initialCollateral amount of initial collateral to be deposited\n     * @param _mintingMaximum    maximal amount of OFD that can be minted by the position owner\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\n     * @param _riskPremium       ppm of minted amount that is added to the applicible minting fee as a risk premium\n     * @param _liqPrice          Liquidation price with (36 - token decimals) decimals,\n     *                           e.g. 18 decimals for an 18 dec collateral, 36 decs for a 0 dec collateral.\n     * @param _reservePPM        ppm of minted amount that is locked as borrower's reserve, e.g. 20%\n     * @return address           address of created position\n     */\n\tfunction openPosition(\n\t\taddress _collateralAddress,\n\t\tuint256 _minCollateral,\n\t\tuint256 _initialCollateral,\n\t\tuint256 _mintingMaximum,\n\t\tuint40 _initPeriodSeconds,\n\t\tuint40 _expirationSeconds,\n\t\tuint40 _challengeSeconds,\n\t\tuint24 _riskPremium,\n\t\tuint256 _liqPrice,\n\t\tuint24 _reservePPM\n\t) public returns (address) {\n\t\t{\n\t\t\trequire(_riskPremium <= 1000000);\n\t\t\trequire(CHALLENGER_REWARD <= _reservePPM && _reservePPM <= 1000000);\n\t\t\trequire(IERC20(_collateralAddress).decimals() <= 24); // leaves 12 digits for price\n\t\t\tuint256 invalidAmount = IERC20(_collateralAddress).totalSupply() + 1;\n\t\t\ttry IERC20(_collateralAddress).transfer(address(0x123), invalidAmount) {\n\t\t\t\trevert IncompatibleCollateral(); // we need a collateral that reverts on failed transfers\n\t\t\t} catch Error(string memory /*reason*/) {\n\t\t\t} catch Panic(uint /*errorCode*/) {\n\t\t\t} catch (bytes memory /*lowLevelData*/) {\n\t\t\t}\n\t\t\tif (_initialCollateral < _minCollateral) revert InsufficientCollateral();\n\t\t\tif (_minCollateral * _liqPrice < 3500 ether * 10 ** 18) revert InsufficientCollateral(); // must start with at least 3500 OFD worth of collateral\n\t\t}\n\t\tIPosition pos = IPosition(\n\t\t\tPOSITION_FACTORY.createNewPosition(\n\t\t\t\tmsg.sender,\n\t\t\t\taddress(ofd),\n\t\t\t\t_collateralAddress,\n\t\t\t\t_minCollateral,\n\t\t\t\t_mintingMaximum,\n\t\t\t\t_initPeriodSeconds,\n\t\t\t\t_expirationSeconds,\n\t\t\t\t_challengeSeconds,\n\t\t\t\t_riskPremium,\n\t\t\t\t_liqPrice,\n\t\t\t\t_reservePPM\n\t\t\t)\n\t\t);\n\t\tofd.registerPosition(address(pos));\n\t\tofd.collectProfits(msg.sender, OPENING_FEE);\n\t\tIERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\n\n\t\temit PositionOpened(msg.sender, address(pos), address(pos), _collateralAddress);\n\t\treturn address(pos);\n\t}\n\n\tfunction clone(address parent, uint256 _initialCollateral, uint256 _initialMint, uint40 expiration) public returns (address) {\n\t\treturn clone(msg.sender, parent, _initialCollateral, _initialMint, expiration);\n\t}\n\n\t/**\n     * @notice Clones an existing position and immediately tries to mint the specified amount using the given collateral.\n     * @dev This needs an allowance to be set on the collateral contract such that the minting hub can get the collateral.\n     */\n\tfunction clone(address owner, address parent, uint256 _initialCollateral, uint256 _initialMint, uint40 expiration) public validPos(parent) returns (address) {\n\t\taddress pos = POSITION_FACTORY.clonePosition(parent);\n\t\tIPosition child = IPosition(pos);\n\t\tchild.initialize(parent, expiration);\n\t\tofd.registerPosition(pos);\n\t\tIERC20 collateral = child.collateral();\n\t\tif (_initialCollateral < child.minimumCollateral()) revert InsufficientCollateral();\n\t\tcollateral.transferFrom(msg.sender, pos, _initialCollateral); // collateral must still come from sender for security\n\t\temit PositionOpened(owner, address(pos), parent, address(collateral));\n\t\tchild.mint(owner, _initialMint);\n\t\tOwnable(address(child)).transferOwnership(owner);\n\t\treturn address(pos);\n\t}\n\n\t/**\n     * @notice Launch a challenge (Dutch auction) on a position\n     * @param _positionAddr      address of the position we want to challenge\n     * @param _collateralAmount  amount of the collateral we want to challenge\n     * @param minimumPrice       position.price() to guard against the minter fruntrunning with a price change\n     * @return index of the challenge in challenge-array\n     */\n\tfunction challenge(\n\t\taddress _positionAddr,\n\t\tuint256 _collateralAmount,\n\t\tuint256 minimumPrice\n\t) external validPos(_positionAddr) returns (uint256) {\n\t\tIPosition position = IPosition(_positionAddr);\n\t\t// challenger should be ok if frontrun by owner with a higher price\n\t\t// in case owner fruntruns challenger with small price decrease to prevent challenge,\n\t\t// the challenger should set minimumPrice to market price\n\t\tif (position.price() < minimumPrice) revert UnexpectedPrice();\n\t\tIERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\n\t\tuint256 pos = challenges.length;\n\t\tchallenges.push(Challenge(msg.sender, uint40(block.timestamp), position, _collateralAmount));\n\t\tposition.notifyChallengeStarted(_collateralAmount);\n\t\temit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\n\t\treturn pos;\n\t}\n\n\t/**\n     * @notice Post a bid in OFD given an open challenge.\n     *\n     * @dev In case that the collateral cannot be transfered back to the challenger (i.e. because the collateral token\n     * has a blacklist and the challenger is on it), it is possible to postpone the return of the collateral.\n     *\n     * @param _challengeNumber  index of the challenge as broadcast in the event\n     * @param size              how much of the collateral the caller wants to bid for at most\n     *                          (automatically reduced to the available amount)\n     * @param postponeCollateralReturn To postpone the return of the collateral to the challenger. Usually false.\n     */\n\tfunction bid(uint32 _challengeNumber, uint256 size, bool postponeCollateralReturn) external {\n\t\tChallenge memory _challenge = challenges[_challengeNumber];\n\t\t(uint256 liqPrice, uint40 phase) = _challenge.position.challengeData();\n\t\tsize = _challenge.size < size ? _challenge.size : size; // cannot bid for more than the size of the challenge\n\n\t\tif (block.timestamp <= _challenge.start + phase) {\n\t\t\t_avertChallenge(_challenge, _challengeNumber, liqPrice, size);\n\t\t\temit ChallengeAverted(address(_challenge.position), _challengeNumber, size);\n\t\t} else {\n\t\t\t_returnChallengerCollateral(_challenge, _challengeNumber, size, postponeCollateralReturn);\n\t\t\t(uint256 transferredCollateral, uint256 offer) = _finishChallenge(_challenge, liqPrice, phase, size);\n\t\t\temit ChallengeSucceeded(address(_challenge.position), _challengeNumber, offer, transferredCollateral, size);\n\t\t}\n\t}\n\n\tfunction _finishChallenge(Challenge memory _challenge, uint256 liqPrice, uint40 phase, uint256 size) internal returns (uint256, uint256) {\n\t\t// Repayments depend on what was actually minted, whereas bids depend on the available collateral\n\t\t(address owner, uint256 collateral, uint256 repayment, uint32 reservePPM) = _challenge.position.notifyChallengeSucceeded(msg.sender, size);\n\n\t\t// No overflow possible thanks to invariant (col * price <= limit * 10**18)\n\t\t// enforced in Position.setPrice and knowing that collateral <= col.\n\t\tuint256 offer = (_calculatePrice(_challenge.start + phase, phase, liqPrice) * collateral) / 10 ** 18;\n\t\tofd.transferFrom(msg.sender, address(this), offer); // get money from bidder\n\t\tuint256 reward = (offer * CHALLENGER_REWARD) / 1000_000;\n\t\tofd.transfer(_challenge.challenger, reward); // pay out the challenger reward\n\t\tuint256 fundsAvailable = offer - reward; // funds available after reward\n\n\t\t// Example: available funds are 90, repayment is 50, reserve 20%. Then 20%*(90-50)=16 are collected as profits\n\t\t// and the remaining 34 are sent to the position owner. If the position owner maxed out debt before the challenge\n\t\t// started and the liquidation price was 100, they would be slightly better off as they would get away with 80\n\t\t// instead of 40+36 = 76 in this example.\n\t\tif (fundsAvailable > repayment) {\n\t\t\t// The excess amount is distributed between the system and the owner using the reserve ratio\n\t\t\t// At this point, we cannot rely on the liquidation price because the challenge might have been started as a\n\t\t\t// response to an unreasonable increase of the liquidation price, such that we have to use this heuristic\n\t\t\t// for excess fund distribution, which make position owners that maxed out their positions slightly better\n\t\t\t// off in comparison to those who did not.\n\t\t\tuint256 profits = (reservePPM * (fundsAvailable - repayment)) / 1000_000;\n\t\t\tofd.collectProfits(address(this), profits);\n\t\t\tofd.transfer(owner, fundsAvailable - repayment - profits);\n\t\t} else if (fundsAvailable < repayment) {\n\t\t\tofd.coverLoss(address(this), repayment - fundsAvailable); // ensure we have enough to pay everything\n\t\t}\n\t\tofd.burnWithoutReserve(repayment, reservePPM); // Repay the challenged part, example: 50 OFD leading to 10 OFD in implicit profits\n\t\treturn (collateral, offer);\n\t}\n\n\tfunction _avertChallenge(Challenge memory _challenge, uint32 number, uint256 liqPrice, uint256 size) internal {\n\t\trequire(block.timestamp != _challenge.start); // do not allow to avert the challenge in the same transaction\n\t\tif (msg.sender == _challenge.challenger) {\n\t\t\t// allow challenger to cancel challenge without paying themselves\n\t\t} else {\n\t\t\tofd.transferFrom(msg.sender, _challenge.challenger, (size * liqPrice) / (10 ** 18));\n\t\t}\n\n\t\t_challenge.position.notifyChallengeAverted(size);\n\t\t_challenge.position.collateral().transfer(msg.sender, size);\n\t\tif (size < _challenge.size) {\n\t\t\tchallenges[number].size = _challenge.size - size;\n\t\t} else {\n\t\t\trequire(size == _challenge.size);\n\t\t\tdelete challenges[number];\n\t\t}\n\t}\n\n\t/**\n     * @notice Returns 'amount' of the collateral to the challenger and reduces or deletes the relevant challenge.\n     */\n\tfunction _returnChallengerCollateral(\n\t\tChallenge memory _challenge,\n\t\tuint32 number,\n\t\tuint256 amount,\n\t\tbool postpone\n\t) internal {\n\t\t_returnCollateral(_challenge.position.collateral(), _challenge.challenger, amount, postpone);\n\t\tif (_challenge.size == amount) {\n\t\t\t// bid on full amount\n\t\t\tdelete challenges[number];\n\t\t} else {\n\t\t\t// bid on partial amount\n\t\t\tchallenges[number].size -= amount;\n\t\t}\n\t}\n\n\t/**\n     * @notice Calculates the current Dutch auction price.\n     * @dev Starts at the full price at time 'start' and linearly goes to 0 as 'phase2' passes.\n     */\n\tfunction _calculatePrice(uint40 start, uint40 phase2, uint256 liqPrice) internal view returns (uint256) {\n\t\tuint40 timeNow = uint40(block.timestamp);\n\t\tif (timeNow <= start) {\n\t\t\treturn liqPrice;\n\t\t} else if (timeNow >= start + phase2) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tuint256 timeLeft = phase2 - (timeNow - start);\n\t\t\treturn (liqPrice / phase2) * timeLeft;\n\t\t}\n\t}\n\n\t/**\n     * @notice Get the price per unit of the collateral for the given challenge.\n     * @dev The price comes with (36-collateral.decimals()) digits, such that multiplying it with the\n     * raw collateral amount always yields a price with 36 digits, or 18 digits after dividing by 10**18 again.\n     */\n\tfunction price(uint32 challengeNumber) public view returns (uint256) {\n\t\tChallenge memory _challenge = challenges[challengeNumber];\n\t\tif (_challenge.challenger == address(0x0)) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t(uint256 liqPrice, uint40 phase) = _challenge.position.challengeData();\n\t\t\treturn _calculatePrice(_challenge.start + phase, phase, liqPrice);\n\t\t}\n\t}\n\n\t/**\n     * @notice Challengers can call this method to withdraw collateral whose return was postponed.\n     */\n\tfunction returnPostponedCollateral(address collateral, address target) external {\n\t\tuint256 amount = pendingReturns[collateral][msg.sender];\n\t\tdelete pendingReturns[collateral][msg.sender];\n\t\tIERC20(collateral).transfer(target, amount);\n\t}\n\n\tfunction _returnCollateral(IERC20 collateral, address recipient, uint256 amount, bool postpone) internal {\n\t\tif (postpone) {\n\t\t\t// Postponing helps in case the challenger was blacklisted or otherwise cannot receive at the moment.\n\t\t\tpendingReturns[address(collateral)][recipient] += amount;\n\t\t\temit PostPonedReturn(address(collateral), recipient, amount);\n\t\t} else {\n\t\t\tcollateral.transfer(recipient, amount); // return the challenger's collateral\n\t\t}\n\t}\n\n\t/**\n     * The applicable purchase price when forcing the sale of collateral of an expired position.\n     *\n     * The price starts at 10x the liquidation price at the expiration time, linearly declines to\n     * 1x liquidation price over the course of one challenge period, and then linearly declines\n     * less steeply to 0 over the course of another challenge period.\n     */\n\tfunction expiredPurchasePrice(IPosition pos) public view returns (uint256) {\n\t\tuint256 liqprice = pos.price();\n\t\tuint256 expiration = pos.expiration();\n\t\tif (block.timestamp <= expiration) {\n\t\t\treturn EXPIRED_PRICE_FACTOR * liqprice;\n\t\t} else {\n\t\t\tuint256 challengePeriod = pos.challengePeriod();\n\t\t\tuint256 timePassed = block.timestamp - expiration;\n\t\t\tif (timePassed <= challengePeriod) {\n\t\t\t\t// from 10x liquidation price to 1x in first phase\n\t\t\t\tuint256 timeLeft = challengePeriod - timePassed;\n\t\t\t\treturn liqprice + (((EXPIRED_PRICE_FACTOR - 1) * liqprice) / challengePeriod) * timeLeft;\n\t\t\t} else if (timePassed < 2 * challengePeriod) {\n\t\t\t\t// from 1x liquidation price to 0 in second phase\n\t\t\t\tuint256 timeLeft = 2 * challengePeriod - timePassed;\n\t\t\t\treturn (liqprice / challengePeriod) * timeLeft;\n\t\t\t} else {\n\t\t\t\t// get collateral for free after both phases passed\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n     * Buys up to the desired amount of the collateral asset from the given expired position using\n     * the applicable 'expiredPurchasePrice' in that instant.\n     */\n\tfunction buyExpiredCollateral(IPosition pos, uint256 upToAmount) external returns (uint256) {\n\t\tuint256 max = pos.collateral().balanceOf(address(pos));\n\t\tuint256 amount = upToAmount > max ? max : upToAmount;\n\t\tuint256 forceSalePrice = expiredPurchasePrice(pos);\n\t\tuint256 costs = (forceSalePrice * amount) / 10 ** 18;\n\t\tpos.forceSale(msg.sender, amount, costs);\n\t\temit ForcedSale(address(pos), amount, forceSalePrice);\n\t\treturn amount;\n\t}\n}\n"
    },
    "contracts/OracleFreeDollar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./utils/ERC20PermitLight.sol\";\nimport \"./Equity.sol\";\nimport \"./interface/IReserve.sol\";\nimport \"./interface/IOracleFreeDollar.sol\";\n\n/**\n * @title OracleFreeDollar\n * @notice The OracleFreeDollar (OFD) is an ERC-20 token that is designed to track the value of the American Dollar.\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\n */\ncontract OracleFreeDollar is ERC20PermitLight, IOracleFreeDollar {\n    /**\n     * @notice Minimal fee and application period when suggesting a new minter.\n     */\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n\n    /**\n     * @notice The contract that holds the reserve.\n     */\n    IReserve public immutable override reserve;\n\n    /**\n     * @notice How much of the reserve belongs to the minters. Everything else belongs to the pool share holders.\n     * Stored with 6 additional digits of accuracy so no rounding is necessary when dealing with parts per\n     * million (ppm) in reserve calculations.\n     */\n    uint256 private minterReserveE6;\n\n    /**\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n     * to mint OracleFreeDollars.\n     */\n    mapping(address minter => uint256 validityStart) public minters;\n\n    /**\n     * @notice List of positions that are allowed to mint and the minter that registered them.\n     */\n    mapping(address position => address registeringMinter) public positions;\n\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n    event MinterDenied(address indexed minter, string message);\n    event Loss(address indexed reportingMinter, uint256 amount);\n    event Profit(address indexed reportingMinter, uint256 amount);\n\n    error PeriodTooShort();\n    error FeeTooLow();\n    error AlreadyRegistered();\n    error NotMinter();\n    error TooLate();\n\n    modifier minterOnly() {\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\n        _;\n    }\n\n    /**\n     * @notice Initiates the OracleFreeDollar with the provided minimum application period for new plugins\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\n     */\n    constructor(uint256 _minApplicationPeriod) ERC20(18) {\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n        reserve = new Equity(this);\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"OracleFreeDollar\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"OFD\";\n    }\n\n    function initialize(address _minter, string calldata _message) external {\n        require(totalSupply() == 0 && reserve.totalSupply() == 0);\n        minters[_minter] = block.timestamp;\n        emit MinterApplied(_minter, 0, 0, _message);\n    }\n\n    /**\n     * @notice Publicly accessible method to suggest a new way of minting OracleFreeDollar.\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\n     * adds value to the OracleFreeDollar system. Complex proposals should have application periods and applications fees\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\n     * the proposed minter.\n     *\n     * @param _minter              An address that is given the permission to mint OracleFreeDollars\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\n     * @param _message             An optional human readable message to everyone watching this contract\n     */\n    function suggestMinter(\n        address _minter,\n        uint256 _applicationPeriod,\n        uint256 _applicationFee,\n        string calldata _message\n    ) external override {\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\n        if (minters[_minter] != 0) revert AlreadyRegistered();\n        _collectProfits(address(this), msg.sender, _applicationFee);\n        minters[_minter] = block.timestamp + _applicationPeriod;\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n    }\n\n    /**\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\n     * giving them arbitrary allowances does not pose an additional risk.\n     */\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\n        uint256 explicit = super._allowance(owner, spender);\n        if (explicit > 0) {\n            return explicit; // don't waste gas checking minter\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\n            return INFINITY;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice The reserve provided by the owners of collateralized positions.\n     * @dev The minter reserve can be used to cover losses after the equity holders have been wiped out.\n     */\n    function minterReserve() public view returns (uint256) {\n        return minterReserveE6 / 1000000;\n    }\n\n    /**\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint OracleFreeDollars.\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\n     */\n    function registerPosition(address _position) external override {\n        if (!isMinter(msg.sender)) revert NotMinter();\n        positions[_position] = msg.sender;\n    }\n\n    /**\n     * @notice The amount of equity of the OracleFreeDollar system in OFD, owned by the holders of OracleFreeDollar Pool Shares.\n     * @dev Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\n     * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\n     * constitutes profits attributable to the pool share holders.\n     */\n    function equity() public view returns (uint256) {\n        uint256 balance = balanceOf(address(reserve));\n        uint256 minReserve = minterReserve();\n        if (balance <= minReserve) {\n            return 0;\n        } else {\n            return balance - minReserve;\n        }\n    }\n\n    /**\n     * @notice Qualified pool share holders can deny minters during the application period.\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\n     */\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\n        if (block.timestamp > minters[_minter]) revert TooLate();\n        reserve.checkQualified(msg.sender, _helpers);\n        delete minters[_minter];\n        emit MinterDenied(_minter, _message);\n    }\n\n    /**\n     * @notice Mints the provided amount of OFD to the target address, automatically forwarding\n     * the minting fee and the reserve to the right place.\n     */\n    function mintWithReserve(\n        address _target,\n        uint256 _amount,\n        uint32 _reservePPM,\n        uint32 _feesPPM\n    ) external override minterOnly {\n        uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\n        _mint(_target, usableMint);\n        _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\n        minterReserveE6 += _amount * _reservePPM;\n        emit Profit(msg.sender, (_feesPPM * _amount) / 1000_000);\n    }\n\n    function mint(address _target, uint256 _amount) external override minterOnly {\n        _mint(_target, _amount);\n    }\n\n    /**\n     * Anyone is allowed to burn their OFD.\n     */\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Burn someone elses OFD.\n     */\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\n        _burn(_owner, _amount);\n    }\n\n    /**\n     * @notice Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the\n     * pool share holders. This can make sense in combination with 'coverLoss', i.e. when it is the pool share\n     * holders that bear the risk and depending on the outcome they make a profit or a loss.\n     *\n     * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with\n     * the same _reservePPM amount.\n     *\n     * For example, if someone minted 50 OFD earlier with a 20% reserve requirement (200000 ppm), they got 40 OFD\n     * and paid 10 OFD into the reserve. Now they want to repay the debt by burning 50 OFD. When doing so using this\n     * method, 50 OFD get burned and on top of that, 10 OFD previously assigned to the minter's reserved are\n     * reassigned to the pool share holders.\n     */\n    function burnWithoutReserve(uint256 amount, uint32 reservePPM) public override minterOnly {\n        _burn(msg.sender, amount);\n        uint256 reserveReduction = amount * reservePPM;\n        if (reserveReduction > minterReserveE6) {\n            emit Profit(msg.sender, minterReserveE6 / 1000_000);\n            minterReserveE6 = 0; // should never happen, but we want robust behavior in case it does\n        } else {\n            minterReserveE6 -= reserveReduction;\n            emit Profit(msg.sender, reserveReduction / 1000_000);\n        }\n    }\n\n    /**\n     * @notice Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve\n     * requirement. The caller is only allowed to use this method for tokens also minted through the caller with the\n     * same _reservePPM amount.\n     *\n     * Example: the calling contract has previously minted 100 OFD with a reserve ratio of 20% (i.e. 200000 ppm).\n     * Now they have 41 OFD that they do not need so they decide to repay that amount. Assuming the reserves are\n     * only 90% covered, the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding\n     * 'debt' of the caller by 50 OFD in total. This total is returned by the method so the caller knows how much less\n     * they owe.\n     */\n    function burnWithReserve(\n        uint256 _amountExcludingReserve,\n        uint32 _reservePPM\n    ) external override minterOnly returns (uint256) {\n        uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM); // 50 in the example\n        minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\n        _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve\n        _burn(msg.sender, freedAmount); // burn the rest of the freed amount\n        return freedAmount;\n    }\n\n    /**\n     * @notice Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\n     * Only use this method for tokens also minted by the caller with the same _reservePPM.\n     *\n     * Example: the calling contract has previously minted 100 OFD with a reserve ratio of 20% (i.e. 200000 ppm).\n     * To burn half of that again, the minter calls burnFrom with a target amount of 50 OFD. Assuming that reserves\n     * are only 90% covered, this call will deduct 41 OFD from the payer's balance and 9 from the reserve, while\n     * reducing the minter reserve by 10.\n     */\n    function burnFromWithReserve(\n        address payer,\n        uint256 targetTotalBurnAmount,\n        uint32 reservePPM\n    ) external override minterOnly returns (uint256) {\n        uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, reservePPM);\n        _transfer(address(reserve), payer, assigned); // send reserve to owner\n        _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\n        minterReserveE6 -= targetTotalBurnAmount * reservePPM; // reduce reserve requirements by original ratio\n        return assigned;\n    }\n\n    /**\n     * @notice Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\n     * Under normal circumstances, this is just the reserver requirement multiplied by the amount. However, after a\n     * severe loss of capital that burned into the minter's reserve, this can also be less than that.\n     */\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n        uint256 theoreticalReserve = (_reservePPM * mintedAmount) / 1000000;\n        uint256 currentReserve = balanceOf(address(reserve));\n        uint256 minterReserve_ = minterReserve();\n        if (currentReserve < minterReserve_) {\n            // not enough reserves, owner has to take a loss\n            return (theoreticalReserve * currentReserve) / minterReserve_;\n        } else {\n            return theoreticalReserve;\n        }\n    }\n\n    /**\n     * @notice Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM,\n     * taking into account potential losses. Example values in the comments.\n     */\n    function calculateFreedAmount(\n        uint256 amountExcludingReserve /* 41 */,\n        uint32 reservePPM /* 20% */\n    ) public view returns (uint256) {\n        uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\n        uint256 minterReserve_ = minterReserve(); // 20\n        uint256 adjustedReservePPM = currentReserve < minterReserve_\n            ? (reservePPM * currentReserve) / minterReserve_\n            : reservePPM; // 18%\n        return (1000000 * amountExcludingReserve) / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\n    }\n\n    /**\n     * @notice Notify the OracleFreeDollar that a minter lost economic access to some coins. This does not mean that the coins are\n     * literally lost. It just means that some OFD will likely never be repaid and that in order to bring the system\n     * back into balance, the lost amount of OFD must be removed from the reserve instead.\n     *\n     * For example, if a minter printed 1 million OFD for a mortgage and the mortgage turned out to be unsound with\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\n     * by the reserve.\n     */\n    function coverLoss(address source, uint256 _amount) external override minterOnly {\n        uint256 reserveLeft = balanceOf(address(reserve));\n        if (reserveLeft >= _amount) {\n            _transfer(address(reserve), source, _amount);\n        } else {\n            _transfer(address(reserve), source, reserveLeft);\n            _mint(source, _amount - reserveLeft);\n        }\n        emit Loss(source, _amount);\n    }\n\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\n        _collectProfits(msg.sender, source, _amount);\n    }\n\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\n        _transfer(source, address(reserve), _amount);\n        emit Profit(minter, _amount);\n    }\n\n    /**\n     * @notice Returns true if the address is an approved minter.\n     */\n    function isMinter(address _minter) public view override returns (bool) {\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\n    }\n\n    /**\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\n     */\n    function getPositionParent(address _position) public view override returns (address) {\n        return positions[_position];\n    }\n}\n"
    },
    "contracts/Position.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './utils/Ownable.sol';\nimport './utils/MathUtil.sol';\n\nimport './interface/IERC20.sol';\nimport './interface/ILeadrate.sol';\nimport './interface/IReserve.sol';\nimport './interface/IOracleFreeDollar.sol';\n\nimport './interface/IPosition.sol';\n\n/**\n * @title Position\n * @notice A collateralized minting position.\n */\ncontract Position is Ownable, IPosition, MathUtil {\n\t/**\n     * @notice Note that this contract is intended to be cloned. All clones will share the same values for\n     * the constant and immutable fields, but have their own values for the other fields.\n     */\n\n\t/**\n     * @notice The ofd price per unit of the collateral below which challenges succeed, (36 - collateral.decimals) decimals\n     */\n\tuint256 public price;\n\n\t/**\n     * @notice Net minted amount, including reserve.\n     */\n\tuint256 public minted;\n\n\t/**\n     * @notice How much has been minted in total. This variable is only used in the parent position.\n     */\n\tuint256 private totalMinted;\n\n\tuint256 public immutable limit;\n\n\t/**\n     * @notice Amount of the collateral that is currently under a challenge.\n     * Used to figure out whether there are pending challenges.\n     */\n\tuint256 public challengedAmount;\n\n\t/**\n     * @notice Challenge period in seconds.\n     */\n\tuint40 public immutable challengePeriod;\n\n\t/**\n     * @notice Timestamp when minting can start and the position no longer denied.\n     */\n\tuint40 public immutable start;\n\n\t/**\n     * @notice End of the latest cooldown. If this is in the future, minting is suspended.\n     */\n\tuint40 public cooldown;\n\n\t/**\n     * @notice Timestamp of the expiration of the position. After expiration, challenges cannot be averted\n     * any more. This is also the basis for fee calculations.\n     */\n\tuint40 public expiration;\n\n\tbool private closed;\n\n\t/**\n     * @notice The original position to help identifying clones.\n     */\n\taddress public immutable original;\n\n\t/**\n     * @notice Pointer to the minting hub.\n     */\n\taddress public immutable hub;\n\n\t/**\n     * @notice The OracleFreeDollar contract.\n     */\n\tIOracleFreeDollar public immutable ofd;\n\n\t/**\n     * @notice The collateral token.\n     */\n\tIERC20 public immutable override collateral;\n\n\t/**\n     * @notice Minimum acceptable collateral amount to prevent dust.\n     */\n\tuint256 public immutable override minimumCollateral;\n\n\t/**\n     * @notice The interest in parts per million per year that is deducted when minting OracleFreeDollars.\n     * To be paid upfront.\n     */\n\tuint24 public immutable riskPremiumPPM;\n\n\t/**\n     * @notice The reserve contribution in parts per million of the minted amount.\n     */\n\tuint24 public immutable reserveContribution;\n\n\tevent MintingUpdate(uint256 collateral, uint256 price, uint256 minted);\n\tevent PositionDenied(address indexed sender, string message); // emitted if closed by governance\n\n\terror InsufficientCollateral(uint256 needed, uint256 available);\n\terror TooLate();\n\terror RepaidTooMuch(uint256 excess);\n\terror LimitExceeded(uint256 tried, uint256 available);\n\terror ChallengeTooSmall();\n\terror Expired(uint40 time, uint40 expiration);\n\terror Alive();\n\terror Closed();\n\terror Hot();\n\terror Challenged();\n\terror NotHub();\n\terror NotOriginal();\n\terror InvalidExpiration();\n\terror AlreadyInitialized();\n\n\tmodifier alive() {\n\t\tif (block.timestamp >= expiration) revert Expired(uint40(block.timestamp), expiration);\n\t\t_;\n\t}\n\n\t// requires that the position has always been backed by a minimal amount of collateral\n\tmodifier backed() {\n\t\tif (isClosed()) revert Closed();\n\t\t_;\n\t}\n\n\tmodifier expired() {\n\t\tif (block.timestamp < expiration) revert Alive();\n\t\t_;\n\t}\n\n\tmodifier noCooldown() {\n\t\tif (block.timestamp <= cooldown) revert Hot();\n\t\t_;\n\t}\n\n\tmodifier noChallenge() {\n\t\tif (challengedAmount > 0) revert Challenged();\n\t\t_;\n\t}\n\n\tmodifier onlyHub() {\n\t\tif (msg.sender != address(hub)) revert NotHub();\n\t\t_;\n\t}\n\n\tmodifier ownerOrRoller() {\n\t\tif (msg.sender != address(IHub(hub).roller())) _requireOwner(msg.sender);\n\t\t_;\n\t}\n\n\t/**\n     * @dev See MintingHub.openPosition\n     */\n\tconstructor(address _owner, address _hub, address _ofd, address _collateral,\n\t\tuint256 _minCollateral, uint256 _initialLimit,\n\t\tuint40 _initPeriod, uint40 _duration, uint40 _challengePeriod,\n\t\tuint24 _riskPremiumPPM, uint256 _liqPrice, uint24 _reservePPM) {\n\t\trequire(_initPeriod >= 3 days); // must be at least three days, recommended to use higher values\n\t\t_setOwner(_owner);\n\t\toriginal = address(this);\n\t\thub = _hub;\n\t\tofd = IOracleFreeDollar(_ofd);\n\t\tcollateral = IERC20(_collateral);\n\t\triskPremiumPPM = _riskPremiumPPM;\n\t\treserveContribution = _reservePPM;\n\t\tminimumCollateral = _minCollateral;\n\t\tchallengePeriod = _challengePeriod;\n\t\tstart = uint40(block.timestamp) + _initPeriod; // at least three days time to deny the position\n\t\tcooldown = start;\n\t\texpiration = start + _duration;\n\t\tlimit = _initialLimit;\n\t\t_setPrice(_liqPrice, _initialLimit);\n\t}\n\n\t/**\n     * Initialization method for clones.\n     * Can only be called once. Should be called immediately after creating the clone.\n     */\n\tfunction initialize(address parent, uint40 _expiration) external onlyHub {\n\t\tif (expiration != 0) revert AlreadyInitialized();\n\t\tif (_expiration < block.timestamp || _expiration > Position(original).expiration()) revert InvalidExpiration(); // expiration must not be later than original\n\t\texpiration = _expiration;\n\t\tprice = Position(parent).price();\n\t\t_setOwner(hub);\n\t}\n\n\t/**\n     * Cloning a position is only allowed if the position is not challenged, not expired and not in cooldown.\n     */\n\tfunction assertCloneable() external noChallenge noCooldown alive backed {}\n\n\t/**\n     * Notify the original that some amount has been minted.\n     */\n\tfunction notifyMint(uint256 mint_) external {\n\t\tif (ofd.getPositionParent(msg.sender) != hub) revert NotHub();\n\t\ttotalMinted += mint_;\n\t}\n\n\tfunction notifyRepaid(uint256 repaid_) external {\n\t\tif (ofd.getPositionParent(msg.sender) != hub) revert NotHub();\n\t\ttotalMinted -= repaid_;\n\t}\n\n\t/**\n     * Should only be called on the original position.\n     * Better use 'availableForMinting'.\n     */\n\tfunction availableForClones() external view returns (uint256) {\n\t\t// reserve capacity for the original to the extent the owner provided collateral\n\t\tuint256 potential = (_collateralBalance() * price) / ONE_DEC18;\n\t\tuint256 unusedPotential = minted > potential ? 0 : potential - minted;\n\t\tif (totalMinted + unusedPotential >= limit) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn limit - totalMinted - unusedPotential;\n\t\t}\n\t}\n\n\t/**\n     * The amount available for minting in this position family.\n     *\n     * Does not check if positions are challenged, closed, or under cooldown.\n     */\n\tfunction availableForMinting() public view returns (uint256) {\n\t\tif (address(this) == original) {\n\t\t\treturn limit - totalMinted;\n\t\t} else {\n\t\t\treturn Position(original).availableForClones();\n\t\t}\n\t}\n\n\t/**\n     * @notice Qualified pool share holders can call this method to immediately expire a freshly proposed position.\n     */\n\tfunction deny(address[] calldata helpers, string calldata message) external {\n\t\tif (block.timestamp >= start) revert TooLate();\n\t\tIReserve(ofd.reserve()).checkQualified(msg.sender, helpers);\n\t\t_close();\n\t\temit PositionDenied(msg.sender, message);\n\t}\n\n\t/**\n     * Closes the position by putting it into eternal cooldown.\n     * This allows the users to still withdraw the collateral that is left, but never to mint again.\n     */\n\tfunction _close() internal {\n\t\tclosed = true;\n\t}\n\n\tfunction isClosed() public view returns (bool) {\n\t\treturn closed;\n\t}\n\n\t/**\n     * @notice This is how much the minter can actually use when minting OFD, with the rest being used\n     * assigned to the minter reserve or (if applicable) fees.\n     */\n\tfunction getUsableMint(uint256 totalMint, bool afterFees) public view returns (uint256) {\n\t\tif (afterFees) {\n\t\t\treturn (totalMint * (1000_000 - reserveContribution - calculateCurrentFee())) / 1000_000;\n\t\t} else {\n\t\t\treturn (totalMint * (1000_000 - reserveContribution)) / 1000_000;\n\t\t}\n\t}\n\n\t/**\n     * Returns the corresponding mint amount (disregarding the limit).\n     */\n\tfunction getMintAmount(uint256 usableMint) external view returns (uint256) {\n\t\treturn usableMint == 0 ? 0 :(usableMint * 1000_000 - 1) / (1000_000 - reserveContribution - calculateCurrentFee()) + 1;\n\t}\n\n\t/**\n     * @notice \"All in one\" function to adjust the outstanding amount of OFD, the collateral amount,\n     * and the price in one transaction.\n     */\n\tfunction adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) external onlyOwner {\n\t\tuint256 colbal = _collateralBalance();\n\t\tif (newCollateral > colbal) {\n\t\t\tcollateral.transferFrom(msg.sender, address(this), newCollateral - colbal);\n\t\t}\n\t\t// Must be called after collateral deposit, but before withdrawal\n\t\tif (newMinted < minted) {\n\t\t\tofd.burnFromWithReserve(msg.sender, minted - newMinted, reserveContribution);\n\t\t\t_notifyRepaid(minted - newMinted);\n\t\t}\n\t\tif (newCollateral < colbal) {\n\t\t\t_withdrawCollateral(msg.sender, colbal - newCollateral);\n\t\t}\n\t\t// Must be called after collateral withdrawal\n\t\tif (newMinted > minted) {\n\t\t\t_mint(msg.sender, newMinted - minted, newCollateral);\n\t\t}\n\t\tif (newPrice != price) {\n\t\t\t_adjustPrice(newPrice);\n\t\t}\n\t\temit MintingUpdate(newCollateral, newPrice, newMinted);\n\t}\n\n\t/**\n     * @notice Allows the position owner to adjust the liquidation price as long as there is no pending challenge.\n     * Lowering the liquidation price can be done with immediate effect, given that there is enough collateral.\n     * Increasing the liquidation price triggers a cooldown period of 3 days, during which minting is suspended.\n     */\n\tfunction adjustPrice(uint256 newPrice) public onlyOwner {\n\t\t_adjustPrice(newPrice);\n\t\temit MintingUpdate(_collateralBalance(), price, minted);\n\t}\n\n\tfunction _adjustPrice(uint256 newPrice) internal noChallenge alive backed {\n\t\tif (newPrice > price) {\n\t\t\t_restrictMinting(3 days);\n\t\t} else {\n\t\t\t_checkCollateral(_collateralBalance(), newPrice);\n\t\t}\n\t\t_setPrice(newPrice, minted + availableForMinting());\n\t}\n\n\tfunction _setPrice(uint256 newPrice, uint256 bounds) internal {\n\t\trequire(newPrice * minimumCollateral <= bounds * ONE_DEC18); // sanity check\n\t\tprice = newPrice;\n\t}\n\n\tfunction _collateralBalance() internal view returns (uint256) {\n\t\treturn IERC20(collateral).balanceOf(address(this));\n\t}\n\n\t/**\n     * @notice Mint OFD as long as there is no open challenge, the position is not subject to a cooldown,\n     * and there is sufficient collateral.\n     */\n\tfunction mint(address target, uint256 amount) public ownerOrRoller {\n\t\tuint256 collateralBalance = _collateralBalance();\n\t\t_mint(target, amount, collateralBalance);\n\t\temit MintingUpdate(collateralBalance, price, minted);\n\t}\n\n\t/**\n     * The applicable upfront fee in ppm when minting more OracleFreeDollars based on the annual interest rate and\n     * the expiration of the position.\n     */\n\tfunction calculateCurrentFee() public view returns (uint24) {\n\t\treturn calculateFee(expiration);\n\t}\n\n\t/**\n     * The applicable interest rate in ppm when minting more OracleFreeDollars.\n     * It consists on the globally valid interest plus an individual risk premium.\n     */\n\tfunction annualInterestPPM() public view returns (uint24) {\n\t\treturn IHub(hub).rate().currentRatePPM() + riskPremiumPPM;\n\t}\n\n\t/**\n     * The fee in ppm when cloning and minting with the given expiration date.\n     */\n\tfunction calculateFee(uint256 exp) public view returns (uint24) {\n\t\tuint256 time = block.timestamp < start ? start : block.timestamp;\n\t\tuint256 timePassed = exp - time;\n\t\t// Time resolution is in the range of minutes for typical interest rates.\n\t\tuint256 feePPM = (timePassed * annualInterestPPM()) / 365 days;\n\t\treturn uint24(feePPM > 1000000 ? 1000000 : feePPM); // fee cannot exceed 100%\n\t}\n\n\tfunction _mint(address target, uint256 amount, uint256 collateral_) internal noChallenge noCooldown alive backed {\n\t\tif (amount > availableForMinting()) revert LimitExceeded(amount, availableForMinting());\n\t\tPosition(original).notifyMint(amount);\n\t\tofd.mintWithReserve(target, amount, reserveContribution, calculateCurrentFee());\n\t\tminted += amount;\n\t\t_checkCollateral(collateral_, price);\n\t}\n\n\tfunction _restrictMinting(uint40 period) internal {\n\t\tuint40 horizon = uint40(block.timestamp) + period;\n\t\tif (horizon > cooldown) {\n\t\t\tcooldown = horizon;\n\t\t}\n\t}\n\n\t/**\n     * @notice Repay some OFD. If too much is repaid, the call fails.\n     * It is possible to repay while there are challenges, but the collateral is locked until all is clear again.\n     *\n     * The repaid amount should fulfill the following equation in order to close the position,\n     * i.e. bring the minted amount to 0:\n     * minted = amount + ofd.calculateAssignedReserve(amount, reservePPM)\n     *\n     * Under normal circumstances, this implies:\n     * amount = minted * (1000000 - reservePPM)\n     *\n     * E.g. if minted is 50 and reservePPM is 200000, it is necessary to repay 40 to be able to close the position.\n     */\n\tfunction repay(uint256 amount) public returns (uint256) {\n\t\tIERC20(ofd).transferFrom(msg.sender, address(this), amount);\n\t\tuint256 actuallyRepaid = IOracleFreeDollar(ofd).burnWithReserve(amount, reserveContribution);\n\t\t_notifyRepaid(actuallyRepaid);\n\t\temit MintingUpdate(_collateralBalance(), price, minted);\n\t\treturn actuallyRepaid;\n\t}\n\n\tfunction _notifyRepaid(uint256 amount) internal {\n\t\tif (amount > minted) revert RepaidTooMuch(amount - minted);\n\t\tPosition(original).notifyRepaid(amount);\n\t\tminted -= amount;\n\t}\n\n\t/**\n     * Force the sale of some collateral after the position is expired.\n     *\n     * Can only be called by the minting hub and the minting hub is trusted to calculate the price correctly.\n     * The proceeds from the sale are first used to repay the outstanding balance and then (if anything is left)\n     * it is sent to the owner of the position.\n     *\n     * Do not allow a forced sale as long as there is an open challenge. Otherwise, a forced sale by the owner\n     * himself could remove any incentive to launch challenges shortly before the expiration. (CS-OFD2-001)\n     */\n\tfunction forceSale(address buyer, uint256 collAmount, uint256 proceeds) external onlyHub expired noChallenge {\n\t\t// send collateral to buyer\n\t\tuint256 remainingCollateral = _sendCollateral(buyer, collAmount);\n\t\tif (minted > 0) {\n\t\t\tuint256 availableReserve = ofd.calculateAssignedReserve(minted, reserveContribution);\n\t\t\tif (proceeds + availableReserve >= minted) {\n\t\t\t\t// repay everything from the buyer's account\n\t\t\t\tuint256 returnedReserve = ofd.burnFromWithReserve(buyer, minted, reserveContribution);\n\t\t\t\tassert(returnedReserve == availableReserve);\n\t\t\t\t// transfer the remaining purchase price from the buyer to the owner\n\t\t\t\tofd.transferFrom(buyer, owner, proceeds + returnedReserve - minted);\n\t\t\t\t_notifyRepaid(minted);\n\t\t\t} else {\n\t\t\t\t// we can only repay a part, nothing left to pay to owner\n\t\t\t\tofd.transferFrom(buyer, address(this), proceeds);\n\t\t\t\tif (remainingCollateral == 0) {\n\t\t\t\t\t// CS-ZCHF2-002, bad debt should be properly handled. In this case, the proceeds from\n\t\t\t\t\t// the forced sale did not suffice to repay the position and there is a loss\n\t\t\t\t\tofd.coverLoss(address(this), minted - proceeds); // more than we need, but returned again on next line\n\t\t\t\t\tofd.burnWithoutReserve(minted, reserveContribution);\n\t\t\t\t\t_notifyRepaid(minted);\n\t\t\t\t} else {\n\t\t\t\t\tuint256 repaid = ofd.burnWithReserve(proceeds, reserveContribution);\n\t\t\t\t\t_notifyRepaid(repaid);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// wire funds directly to owner\n\t\t\tofd.transferFrom(buyer, owner, proceeds);\n\t\t}\n\t\temit MintingUpdate(_collateralBalance(), price, minted);\n\t}\n\n\t/**\n     * @notice Withdraw any ERC20 token that might have ended up on this address.\n     * Withdrawing collateral is subject to the same restrictions as withdrawCollateral(...).\n     */\n\tfunction withdraw(address token, address target, uint256 amount) external onlyOwner {\n\t\tif (token == address(collateral)) {\n\t\t\twithdrawCollateral(target, amount);\n\t\t} else {\n\t\t\tuint256 balance = _collateralBalance();\n\t\t\tIERC20(token).transfer(target, amount);\n\t\t\trequire(balance == _collateralBalance()); // guard against double-entry-point tokens\n\t\t}\n\t}\n\n\t/**\n     * @notice Withdraw collateral from the position up to the extent that it is still well collateralized afterwards.\n     * Not possible as long as there is an open challenge or the contract is subject to a cooldown.\n     *\n     * Withdrawing collateral below the minimum collateral amount formally closes the position.\n     */\n\tfunction withdrawCollateral(address target, uint256 amount) public ownerOrRoller {\n\t\tuint256 balance = _withdrawCollateral(target, amount);\n\t\temit MintingUpdate(balance, price, minted);\n\t}\n\n\tfunction _withdrawCollateral(address target, uint256 amount) internal noChallenge returns (uint256) {\n\t\tif (block.timestamp <= cooldown) revert Hot();\n\t\tuint256 balance = _sendCollateral(target, amount);\n\t\t_checkCollateral(balance, price);\n\t\treturn balance;\n\t}\n\n\tfunction _sendCollateral(address target, uint256 amount) internal returns (uint256) {\n\t\tif (amount > 0) {\n\t\t\t// Some weird tokens fail when trying to transfer 0 amounts\n\t\t\tIERC20(collateral).transfer(target, amount);\n\t\t}\n\t\tuint256 balance = _collateralBalance();\n\t\tif (balance < minimumCollateral) {\n\t\t\t_close();\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n     * @notice This invariant must always hold and must always be checked when any of the three\n     * variables change in an adverse way.\n     */\n\tfunction _checkCollateral(uint256 collateralReserve, uint256 atPrice) internal view {\n\t\tuint256 relevantCollateral = collateralReserve < minimumCollateral ? 0 : collateralReserve;\n\t\tif (relevantCollateral * atPrice < minted * ONE_DEC18) revert InsufficientCollateral(relevantCollateral * atPrice, minted * ONE_DEC18);\n\t}\n\n\t/**\n     * @notice Returns the liquidation price and the durations for phase1 and phase2 of the challenge.\n     * Both phases are usually of equal duration, but near expiration, phase one is adjusted such that\n     * it cannot last beyond the expiration date of the position.\n     */\n\tfunction challengeData() external view returns (uint256 liqPrice, uint40 phase) {\n\t\treturn (price, challengePeriod);\n\t}\n\n\tfunction notifyChallengeStarted(uint256 size) external onlyHub alive {\n\t\t// Require minimum size. Collateral balance can be below minimum if it was partially challenged before.\n\t\tif (size < minimumCollateral && size < _collateralBalance()) revert ChallengeTooSmall();\n\t\tif (size == 0) revert ChallengeTooSmall();\n\t\tchallengedAmount += size;\n\t}\n\n\t/**\n     * @param size   amount of collateral challenged (dec18)\n     */\n\tfunction notifyChallengeAverted(uint256 size) external onlyHub {\n\t\tchallengedAmount -= size;\n\n\t\t// Don't allow minter to close the position immediately so challenge can be repeated before\n\t\t// the owner has a chance to mint more on an undercollateralized position\n\t\t_restrictMinting(1 days);\n\t}\n\n\t/**\n     * @notice Notifies the position that a challenge was successful.\n     * Triggers the payout of the challenged part of the collateral.\n     * Everything else is assumed to be handled by the hub.\n     *\n     * @param _bidder   address of the bidder that receives the collateral\n     * @param _size     amount of the collateral bid for\n     * @return (position owner, effective challenge size in OFD, amount to be repaid, reserve ppm)\n     */\n\tfunction notifyChallengeSucceeded(\n\t\taddress _bidder,\n\t\tuint256 _size\n\t) external onlyHub returns (address, uint256, uint256, uint32) {\n\t\tchallengedAmount -= _size;\n\t\tuint256 colBal = _collateralBalance();\n\t\tif (colBal < _size) {\n\t\t\t_size = colBal;\n\t\t}\n\t\tuint256 repayment = colBal == 0 ? 0 : (minted * _size) / colBal; // for enormous colBal, this could be rounded to 0, which is ok\n\t\t_notifyRepaid(repayment); // we assume the caller takes care of the actual repayment\n\n\t\t// Give time for additional challenges before the owner can mint again. In particular,\n\t\t// the owner might have added collateral only seconds before the challenge ended, preventing a close.\n\t\t_restrictMinting(3 days);\n\n\t\tuint256 newBalance = _sendCollateral(_bidder, _size); // transfer collateral to the bidder and emit update\n\n\t\temit MintingUpdate(newBalance, price, minted);\n\n\t\treturn (owner, _size, repayment, reserveContribution);\n\t}\n}\n\ninterface IHub {\n\tfunction rate() external view returns (ILeadrate);\n\tfunction roller() external view returns (address);\n}\n"
    },
    "contracts/PositionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Position.sol\";\nimport './interface/IOracleFreeDollar.sol';\n\ncontract PositionFactory {\n\t/**\n     * Create a completely new position in a newly deployed contract.\n     * Must be called through minting hub to be recognized as valid position.\n     */\n\tfunction createNewPosition(\n\t\taddress _owner,\n\t\taddress _ofd,\n\t\taddress _collateral,\n\t\tuint256 _minCollateral,\n\t\tuint256 _initialLimit,\n\t\tuint40 _initPeriod,\n\t\tuint40 _duration,\n\t\tuint40 _challengePeriod,\n\t\tuint24 _riskPremiumPPM,\n\t\tuint256 _liqPrice,\n\t\tuint24 _reserve\n\t) external returns (address) {\n\t\treturn\n\t\t\taddress(\n\t\t\tnew Position(\n\t\t\t\t_owner,\n\t\t\t\tmsg.sender,\n\t\t\t\t_ofd,\n\t\t\t\t_collateral,\n\t\t\t\t_minCollateral,\n\t\t\t\t_initialLimit,\n\t\t\t\t_initPeriod,\n\t\t\t\t_duration,\n\t\t\t\t_challengePeriod,\n\t\t\t\t_riskPremiumPPM,\n\t\t\t\t_liqPrice,\n\t\t\t\t_reserve\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n     * @notice clone an existing position. This can be a clone of another clone,\n     * or an original position.\n     * @param _parent address of the position we want to clone\n     * @return address of the newly created clone position\n     */\n\tfunction clonePosition(address _parent) external returns (address) {\n\t\tPosition parent = Position(_parent);\n\t\tparent.assertCloneable();\n\t\tPosition clone = Position(_createClone(parent.original()));\n\t\treturn address(clone);\n\t}\n\n\t// github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\n\tfunction _createClone(address target) internal returns (address result) {\n\t\tbytes20 targetBytes = bytes20(target);\n\t\tassembly {\n\t\t\tlet clone := mload(0x40)\n\t\t\tmstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n\t\t\tmstore(add(clone, 0x14), targetBytes)\n\t\t\tmstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\t\t\tresult := create(0, clone, 0x37)\n\t\t}\n\t\trequire(result != address(0), \"ERC1167: create failed\");\n\t}\n}\n\n"
    },
    "contracts/PositionRoller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './interface/IERC20.sol';\nimport './interface/IOracleFreeDollar.sol';\nimport './interface/IPosition.sol';\nimport './utils/Ownable.sol';\nimport './interface/IReserve.sol';\n\n/**\n * @title PositionRoller\n *\n * Helper to roll over a debt from an old position to a new one.\n * Both positions should have the same collateral. Otherwise, it does not make much sense.\n */\ncontract PositionRoller {\n\n\tIOracleFreeDollar private ofd;\n\n\terror NotOwner(address pos);\n\terror NotPosition(address pos);\n\terror Log(uint256, uint256, uint256);\n\n\tevent Roll(address source, uint256 collWithdraw, uint256 repay, address target, uint256 collDeposit, uint256 mint);\n\n\tconstructor(address ofd_) {\n\t\tofd = IOracleFreeDollar(ofd_);\n\t}\n\n\t/**\n     * Convenience method to roll and old position into a new one.\n     *\n     * Pre-condition is an allowance for the roller to spend the collateral assset on behalf of the caller,\n     * i.e. one should set collateral.approve(roller, collateral.balanceOf(sourcePosition));\n     *\n     * The following is assumed:\n     * - If the limit of the target position permits, the user wants to roll everything\n     * - The user does not want to add additional collateral, but excess collateral is returned\n     * - If not enough can be minted in the new position, it is ok for the roller to use OFD from the msg.sender\n     */\n\tfunction rollFully(IPosition source, IPosition target) external {\n\t\trollFullyWithExpiration(source, target, target.expiration());\n\t}\n\n\t/**\n     * Like rollFully, but with a custom expiration date for the new position.\n     */\n\tfunction rollFullyWithExpiration(IPosition source, IPosition target, uint40 expiration) public {\n\t\trequire(source.collateral() == target.collateral());\n\t\tuint256 repay = findRepaymentAmount(source);\n\t\tuint256 mintAmount = target.getMintAmount(repay);\n\t\tuint256 collateralToWithdraw = IERC20(source.collateral()).balanceOf(address(source));\n\t\tuint256 targetPrice = target.price();\n\t\tuint256 depositAmount = (mintAmount * 10**18 + targetPrice - 1) / targetPrice; // round up\n\t\tif (depositAmount > collateralToWithdraw){\n\t\t\t// If we need more collateral than available from the old position, we opt for taking\n\t\t\t// the missing funds from the caller instead of taking additional collateral from the caller\n\t\t\tdepositAmount = collateralToWithdraw;\n\t\t\tmintAmount = depositAmount * target.price() / 10**18; // round down, rest will be taken from caller\n\t\t}\n\t\troll(source, repay, collateralToWithdraw, target, mintAmount, depositAmount, expiration);\n\t}\n\n\t/**\n     * Doing a binary search is not very efficient, but guaranteed to return a valid result without rounding errors.\n     * To save gas costs, the frontend can also call this and other methods to calculate the right parameters and\n     * then call 'roll' directly.\n     */\n\tfunction findRepaymentAmount(IPosition pos) public view returns (uint256) {\n\t\tuint256 minted = pos.minted();\n\t\tuint24 reservePPM = pos.reserveContribution();\n\t\tif (minted == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 higherResult = ofd.calculateFreedAmount(minted, reservePPM);\n\t\tif (higherResult == minted){\n\t\t\treturn minted;\n\t\t}\n\t\treturn binarySearch(minted, reservePPM, 0, 0, minted, higherResult);\n\t}\n\n\t// max call stack depth is 1024 in solidity. Binary search on 256 bit number takes at most 256 steps, so it should be fine.\n\tfunction binarySearch(uint256 target, uint24 reservePPM, uint256 lowerBound, uint256 lowerResult, uint256 higherBound, uint256 higherResult) internal view returns (uint256) {\n\t\tuint256 middle = (lowerBound + higherBound) / 2;\n\t\tif (middle == lowerBound){\n\t\t\treturn higherBound; // we have reached max precision without exact match, return next higher result to be on the safe side\n\t\t} else {\n\t\t\tuint256 middleResult = ofd.calculateFreedAmount(middle, reservePPM);\n\t\t\tif (middleResult == target){\n\t\t\t\treturn middle;\n\t\t\t} else if (middleResult < target){\n\t\t\t\treturn binarySearch(target, reservePPM, middle, middleResult, higherBound, higherResult);\n\t\t\t} else {\n\t\t\t\treturn binarySearch(target, reservePPM, lowerBound, lowerResult, middle, middleResult);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n     * Rolls the source position into the target position using a flash loan.\n     * Both the source and the target position must recognize this roller.\n     * It is the responsibility of the caller to ensure that both positions are valid contracts.\n     *\n     * @param source The source position, must be owned by the msg.sender .\n     * @param repay The amount to flash loan in order to repay the source position and free up some or all collateral.\n     * @param collWithdraw Collateral to move from the source position to the msg.sender .\n     * @param target The target position. If not owned by msg.sender or if it does not have the desired expiration,\n     *               it is cloned to create a position owned by the msg.sender.\n     * @param mint The amount to be minted from the target position using collateral from msg.sender.\n     * @param collDeposit The amount of collateral to be send from msg.sender to the target position.\n     * @param expiration The desired expiration date for the target position.\n     */\n\tfunction roll(IPosition source, uint256 repay, uint256 collWithdraw, IPosition target, uint256 mint, uint256 collDeposit, uint40 expiration) public valid(source) valid(target) own(source) {\n\t\tofd.mint(address(this), repay); // take a flash loan\n\t\tsource.repay(repay);\n\t\tsource.withdrawCollateral(msg.sender, collWithdraw);\n\t\tif (mint > 0){\n\t\t\tIERC20 targetCollateral = IERC20(target.collateral());\n\t\t\tif (Ownable(address(target)).owner() != msg.sender || expiration != target.expiration()){\n\t\t\t\ttargetCollateral.transferFrom(msg.sender, address(this), collDeposit); // get the new collateral\n\t\t\t\ttargetCollateral.approve(target.hub(), collDeposit); // approve the new collateral and clone:\n\t\t\t\ttarget = IPosition(IMintingHub(target.hub()).clone(msg.sender, address(target), collDeposit, mint, expiration));\n\t\t\t} else {\n\t\t\t\t// We can roll into the provided existing position\n\t\t\t\t// We do not verify whether the target position has been created by the known minting hub in order\n\t\t\t\t// to allow positions to be rolled into future versions of the minting hub\n\t\t\t\ttargetCollateral.transferFrom(msg.sender, address(target), collDeposit);\n\t\t\t\ttarget.mint(msg.sender, mint);\n\t\t\t}\n\t\t}\n\t\tofd.burnFrom(msg.sender, repay); // repay the flash loan\n\t\temit Roll(address(source), collWithdraw, repay, address(target), collDeposit, mint);\n\t}\n\n\tmodifier own(IPosition pos) {\n\t\tif (Ownable(address(pos)).owner() != msg.sender) revert NotOwner(address(pos));\n\t\t_;\n\t}\n\n\tmodifier valid(IPosition pos) {\n\t\tif (ofd.getPositionParent(address(pos)) == address(0x0)) revert NotPosition(address(pos));\n\t\t_;\n\t}\n}\n\ninterface IMintingHub {\n\tfunction clone(address owner, address parent, uint256 _initialCollateral, uint256 _initialMint, uint40 expiration) external returns (address);\n}\n"
    },
    "contracts/Savings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './utils/ERC20.sol';\nimport './interface/IOracleFreeDollar.sol';\nimport './interface/IReserve.sol';\nimport './Leadrate.sol';\n\n/**\n * @title Savings\n *\n * Module to enable savings based on a Leadrate (\"Leitzins\") module.\n *\n * As the interest rate changes, the speed at which 'ticks' are accumulated is\n * adjusted. The ticks counter serves as the basis for calculating the interest\n * due for the individual accounts.\n *\n * The saved OFD are subject to a lockup of up to 3 days and only start to yield\n * an interest after the lockup ended. The purpose of this lockup is to discourage\n * short-term holdings and to avoid paying interest to transactional accounts.\n * Transactional accounts typically do not need an incentive to hold OracleFreeDollars.\n */\ncontract Savings is Leadrate {\n\tuint64 public immutable INTEREST_DELAY = uint64(3 days);\n\n\tIERC20 public immutable ofd;\n\n\tmapping(address => Account) public savings;\n\n\tstruct Account {\n\t\tuint192 saved;\n\t\tuint64 ticks;\n\t}\n\n\tevent Saved(address indexed account , uint192 amount);\n\tevent InterestCollected(address indexed account, uint256 interest);\n\tevent Withdrawn(address indexed account, uint192 amount);\n\n\terror FundsLocked(uint40 remainingSeconds);\n\n\t// The module is considered disabled if the interest is zero or about to become zero within three days.\n\terror ModuleDisabled();\n\n\tconstructor(IOracleFreeDollar ofd_, uint24 initialRatePPM) Leadrate(IReserve(ofd_.reserve()), initialRatePPM) {\n\t\tofd = IERC20(ofd_);\n\t}\n\n\t/**\n     * Shortcut for refreshBalance(msg.sender)\n     */\n\tfunction refreshMyBalance() public returns (uint192) {\n\t\treturn refreshBalance(msg.sender);\n\t}\n\n\t/**\n     * Collects the accrued interest and adds it to the account.\n     *\n     * It can be beneficial to do so every now and then in order to start collecting\n     * interest on the accrued interest.\n     */\n\tfunction refreshBalance(address owner) public returns (uint192) {\n\t\treturn refresh(owner).saved;\n\t}\n\n\tfunction refresh(address accountOwner) internal returns (Account storage) {\n\t\tAccount storage account = savings[accountOwner];\n\t\tuint64 ticks = currentTicks();\n\t\tif (ticks > account.ticks) {\n\t\t\tuint192 earnedInterest = calculateInterest(account, ticks);\n\t\t\tif (earnedInterest > 0) {\n\t\t\t\t// collect interest as you go and trigger accounting event\n\t\t\t\t(IOracleFreeDollar(address(ofd))).coverLoss(address(this), earnedInterest);\n\t\t\t\taccount.saved += earnedInterest;\n\t\t\t\temit InterestCollected(accountOwner, earnedInterest);\n\t\t\t}\n\t\t\taccount.ticks = ticks;\n\t\t}\n\t\treturn account;\n\t}\n\n\tfunction accruedInterest(address accountOwner) public view returns (uint192) {\n\t\treturn accruedInterest(accountOwner, block.timestamp);\n\t}\n\n\tfunction accruedInterest(address accountOwner, uint256 timestamp) public view returns (uint192) {\n\t\tAccount memory account = savings[accountOwner];\n\t\treturn calculateInterest(account, ticks(timestamp));\n\t}\n\n\tfunction calculateInterest(Account memory account, uint64 ticks) public view returns (uint192) {\n\t\tif (ticks <= account.ticks || account.ticks == 0) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tuint192 earnedInterest = uint192((uint256(ticks - account.ticks) * account.saved) / 1000000 / 365 days);\n\t\t\tuint256 equity = IOracleFreeDollar(address(ofd)).equity();\n\t\t\tif (earnedInterest > equity) {\n\t\t\t\treturn uint192(equity); // save conversion as equity is smaller than uint192 earnedInterest\n\t\t\t} else {\n\t\t\t\treturn earnedInterest;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n     * Save 'amount'.\n     */\n\tfunction save(uint192 amount) public {\n\t\tsave(msg.sender, amount);\n\t}\n\n\tfunction adjust(uint192 targetAmount) public {\n\t\tAccount storage balance = refresh(msg.sender);\n\t\tif (balance.saved < targetAmount) {\n\t\t\tsave(targetAmount - balance.saved);\n\t\t} else if (balance.saved > targetAmount) {\n\t\t\twithdraw(msg.sender, balance.saved - targetAmount);\n\t\t}\n\t}\n\n\t/**\n     * Send 'amount' to the account of the provided owner.\n     * The funds sent to the account are locked for a while, depending on how much already is in there.\n     */\n\tfunction save(address owner, uint192 amount) public {\n\t\tif (currentRatePPM == 0) revert ModuleDisabled();\n\t\tif (nextRatePPM == 0 && (nextChange <= block.timestamp + INTEREST_DELAY)) revert ModuleDisabled();\n\t\tAccount storage balance = refresh(owner);\n\t\tofd.transferFrom(msg.sender, address(this), amount);\n\t\tuint64 ticks = currentTicks();\n\t\tassert(balance.ticks >= ticks);\n\t\tuint256 saved = balance.saved;\n\t\tuint64 weightedAverage = uint64(\n\t\t\t(saved * (balance.ticks - ticks) + uint256(amount) * currentRatePPM * INTEREST_DELAY) / (saved + amount)\n\t\t);\n\t\tbalance.saved += amount;\n\t\tbalance.ticks = ticks + weightedAverage;\n\t\temit Saved(owner, amount);\n\t}\n\n\t/**\n     * Withdraw up to 'amount' to the target address.\n     * When trying to withdraw more than available, all that is available is withdrawn.\n     * Returns the acutally transferred amount.\n     *\n     * Fails if the funds in the account have not been in the account for long enough.\n     */\n\tfunction withdraw(address target, uint192 amount) public returns (uint256) {\n\t\tAccount storage account = refresh(msg.sender);\n\t\tif (account.ticks > currentTicks()) {\n\t\t\trevert FundsLocked(uint40(account.ticks - currentTicks()) / currentRatePPM);\n\t\t} else if (amount >= account.saved) {\n\t\t\tamount = account.saved;\n\t\t\tdelete savings[msg.sender];\n\t\t} else {\n\t\t\taccount.saved -= amount;\n\t\t}\n\t\tofd.transfer(target, amount);\n\t\temit Withdrawn(msg.sender, amount);\n\t\treturn amount;\n\t}\n}\n"
    },
    "contracts/StablecoinBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interface/IERC20.sol\";\nimport \"./interface/IERC677Receiver.sol\";\nimport \"./interface/IOracleFreeDollar.sol\";\n\n/**\n * @title Stable Coin Bridge\n * @notice A minting contract for another United States Dollar stablecoin ('source stablecoin') that we trust.\n * @author OracleFreeDollar\n */\ncontract StablecoinBridge {\n    IERC20 public immutable usd; // the source stablecoin\n    IOracleFreeDollar public immutable ofd; // the OracleFreeDollar\n\n    /**\n     * @notice The time horizon after which this bridge expires and needs to be replaced by a new contract.\n     */\n    uint256 public immutable horizon;\n\n    /**\n     * The maximum amount of outstanding converted source stablecoins.\n     */\n    uint256 public immutable limit;\n    uint256 public minted;\n\n    error Limit(uint256 amount, uint256 limit);\n    error Expired(uint256 time, uint256 expiration);\n    error UnsupportedToken(address token);\n\n    constructor(address other, address ofdAddress, uint256 limit_) {\n        usd = IERC20(other);\n        ofd = IOracleFreeDollar(ofdAddress);\n        horizon = block.timestamp + 52 weeks;\n        limit = limit_;\n        minted = 0;\n    }\n\n    /**\n     * @notice Convenience method for mint(msg.sender, amount)\n     */\n    function mint(uint256 amount) external {\n        mintTo(msg.sender, amount);\n    }\n\n    /**\n     * @notice Mint the target amount of OracleFreeDollars, taking the equal amount of source coins from the sender.\n     * @dev This only works if an allowance for the source coins has been set and the caller has enough of them.\n     */\n    function mintTo(address target, uint256 amount) public {\n        usd.transferFrom(msg.sender, address(this), amount);\n        _mint(target, amount);\n    }\n\n    function _mint(address target, uint256 amount) internal {\n        if (block.timestamp > horizon) revert Expired(block.timestamp, horizon);\n        ofd.mint(target, amount);\n        minted += amount;\n        if (minted > limit) revert Limit(amount, limit);\n    }\n\n    /**\n     * @notice Convenience method for burnAndSend(msg.sender, amount)\n     */\n    function burn(uint256 amount) external {\n        _burn(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Burn the indicated amount of OracleFreeDollar and send the same number of source coin to the caller.\n     */\n    function burnAndSend(address target, uint256 amount) external {\n        _burn(msg.sender, target, amount);\n    }\n\n    function _burn(address ofdHolder, address target, uint256 amount) internal {\n        ofd.burnFrom(ofdHolder, amount);\n        usd.transfer(target, amount);\n        minted -= amount;\n    }\n}\n"
    },
    "contracts/test/DeployerOracleFreeDollar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../OracleFreeDollar.sol';\nimport '../interface/IReserve.sol';\nimport '../Leadrate.sol';\nimport \"../PositionFactory.sol\";\nimport \"../MintingHub.sol\";\n\ncontract DeployerOracleFreeDollar {\n    string public constant NAME = \"DeployerV0\";\n    OracleFreeDollar public ofd;\n    PositionFactory public factory;\n    Leadrate public leadrate;\n    PositionRoller public roller;\n    MintingHub public mintingHub;\n\n    event Log(address sender, string message);\n\n    constructor(address _ofd) {\n        ofd = new OracleFreeDollar(1);\n        factory = new PositionFactory();\n        roller = new PositionRoller(address(ofd));\n        leadrate = new Leadrate(ofd.reserve(), 20000);\n        mintingHub = new MintingHub(address(ofd), address(leadrate), address(roller), address(factory));\n\n        ofd.initialize(msg.sender, \"Developer\");\n        ofd.initialize(address(this), \"Deployer\");\n        ofd.initialize(address(mintingHub), \"MintingHub\");\n        ofd.initialize(address(roller), \"Roller\");\n    }\n\n    function initA_OracleFreeDollar() public {\n        uint256 toMint = 1_000_000 ether;\n        ofd.mint(address(this), 2 * toMint);\n        IReserve(ofd.reserve()).invest(toMint, 1000 ether);\n\n        // for sender\n        ofd.mint(msg.sender, toMint);\n    }\n\n    function increaseLeadrate() public {\n        leadrate.proposeChange(leadrate.currentRatePPM() + 1000, new address[](0));\n    }\n\n    function revertLeadrate() public {\n        leadrate.proposeChange(leadrate.currentRatePPM(), new address[](0));\n    }\n}\n"
    },
    "contracts/test/FaucetTestDeployment.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./TestToken.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../interface/IOracleFreeDollar.sol\";\n\ncontract FaucetTestDeployment is Ownable {\n    IERC20[] public tokens;\n    IOracleFreeDollar public ofd;\n\n    bool public init = false;\n    uint256 public tokenCnt = 0;\n\n    event NewToken(uint256 id, string name, string symbol, address token);\n    event NewOfd(address member, address to, uint256 amount);\n    event NewMint(address member, address to, uint256 amount);\n\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    function setOfd(address _ofd) public onlyOwner {\n        ofd = IOracleFreeDollar(_ofd); // needs suggest minter\n    }\n\n    function initTokens() public onlyOwner {\n        require(init == false, \"Already done\");\n        createToken(\"Wrapped Bitcoin\", \"WBTC\", 8);\n        createToken(\"Uniswap\", \"UNI\", 18);\n        createToken(\"Supercoin\", \"SUP\", 18);\n        createToken(\"Bees Protocol\", \"BEES\", 4); // use dif. decs\n        createToken(\"Boss AG\", \"BOSS\", 0); // use dif. decs\n        createToken(\"Unreal\", \"REALU\", 9); // use dif. decs\n        init = true;\n    }\n\n    function createToken(string memory name, string memory symbol, uint8 dec) public onlyOwner {\n        TestToken newToken = new TestToken(name, symbol, dec);\n        tokens.push(newToken);\n        emit NewToken(tokenCnt, name, symbol, address(newToken));\n        tokenCnt++;\n    }\n\n    function mintTo(address to, uint256 amount) public {\n        for (uint256 i = 0; i < tokenCnt; i++) {\n            TestToken token = TestToken(address(tokens[i]));\n            token.mint(to, amount * 10 ** token.decimals());\n        }\n        emit NewMint(msg.sender, to, amount);\n    }\n\n    function mintZofdTo(address to, uint256 amount) public {\n        ofd.mint(to, amount);\n        emit NewOfd(msg.sender, to, amount);\n    }\n\n    function mint() public {\n        mintZofdTo(msg.sender, 100_000 ether);\n        mintTo(msg.sender, 1000);\n    }\n}\n"
    },
    "contracts/test/FreakToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/ERC20.sol\";\n\ncontract FreakToken is ERC20 {\n    string public name;\n    string public symbol;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 dec\n    ) ERC20(dec) {\n        name = name_;\n        symbol = symbol_;\n\n        _mint(msg.sender, 1_000_000 * 1e18);\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        _mint(_account, _amount);\n    }\n\n    function transfer(address, uint256) public virtual override returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/test/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}"
    },
    "contracts/test/MintingHubTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './Strings.sol';\nimport './TestToken.sol';\nimport '../Equity.sol';\nimport '../utils/Ownable.sol';\nimport \"../Position.sol\";\nimport \"../MintingHub.sol\";\nimport '../StablecoinBridge.sol';\nimport '../interface/IPosition.sol';\nimport '../interface/IReserve.sol';\nimport '../interface/IOracleFreeDollar.sol';\nimport '../interface/IERC20.sol';\n\ncontract MintingHubTest {\n    MintingHub hub;\n    StablecoinBridge swap;\n\n    IERC20 usd;\n    TestToken col;\n    IOracleFreeDollar ofd;\n\n    User alice;\n    User bob;\n\n    address latestPosition;\n    uint256 latestChallenge;\n\n    constructor(address hub_, address swap_) {\n        hub = MintingHub(hub_);\n        swap = StablecoinBridge(swap_);\n        col = new TestToken(\"Some Collateral\", \"COL\", uint8(0));\n        usd = swap.usd();\n        ofd = swap.ofd();\n        alice = new User(ofd);\n        bob = new User(ofd);\n        require(ofd.reserve().totalSupply() == 0, Strings.toString(ofd.reserve().totalSupply()));\n    }\n\n    function initiateEquity() public {\n        require(ofd.equity() == 1003849100000000000001, Strings.toString(ofd.equity()));\n        require(ofd.reserve().totalSupply() == 0, Strings.toString(ofd.reserve().totalSupply()));\n        // ensure there is at least 25'000 OFD in equity\n        bob.obtainOracleFreeDollars(swap, 10000 ether);\n        bob.invest(1000 ether);\n        require(ofd.reserve().totalSupply() == 1000 ether, Strings.toString(ofd.reserve().totalSupply()));\n        bob.invest(9000 ether);\n        alice.obtainOracleFreeDollars(swap, 15000 ether);\n        alice.invest(15000 ether);\n        require(ofd.equity() > 25000 ether, Strings.toString(ofd.equity()));\n    }\n\n    function initiateAndDenyPosition() public {\n        alice.obtainOracleFreeDollars(swap, 1000 ether);\n        address pos = alice.initiatePosition(col, hub);\n        bob.deny(hub, pos);\n    }\n\n    function initiatePosition() public {\n        alice.obtainOracleFreeDollars(swap, 1000 ether);\n        latestPosition = alice.initiatePosition(col, hub);\n        require(col.balanceOf(address(alice)) == 0);\n    }\n\n    function testWithdraw() public {\n        alice.testWithdraw(swap, Position(latestPosition));\n    }\n\n    function letAliceMint() public {\n        alice.mint(latestPosition, 1); // test small amount to provoke rounding error\n        alice.transferOwnership(latestPosition, address(bob));\n        uint256 bobbalance = ofd.balanceOf(address(bob));\n        bob.mint(latestPosition, 7);\n        require(ofd.balanceOf(address(bob)) > bobbalance);\n        bob.transferOwnership(latestPosition, address(alice));\n        alice.mint(latestPosition, 0);\n        alice.mint(latestPosition, 100000 * (10 ** 18) - 8);\n        alice.adjustPosition(latestPosition);\n        require(Position(latestPosition).minted() == 100000 ether);\n    }\n\n    function letBobMint() public {\n        bob.mint(latestPosition, 1);\n    }\n\n    uint256 first;\n    uint256 second;\n\n    function letBobChallengePart1() public {\n        col.mint(address(bob), 1300);\n\n        // three challenges in parallel :)\n        first = bob.challenge(hub, latestPosition, 300);\n        second = bob.challenge(hub, latestPosition, 400);\n        latestChallenge = bob.challenge(hub, latestPosition, 500);\n    }\n\n    function letBobChallengePart2() public returns (uint256) {\n        /* alice.avertChallenge(hub, swap, first);\n        bob.obtainOracleFreeDollars(swap, 30_000 ether);\n        bob.bid(hub, second, 10_000 ether);\n        bob.bid(hub, latestChallenge, 20_000 ether);\n        (address challenger, , , , , uint256 bid) = hub.challenges(\n            latestChallenge\n        );\n        require(challenger != address(0x0), \"challenge not found\");\n        require(bid == 20_000 ether);\n        return latestChallenge; */\n    }\n\n    function endChallenges() public {\n        uint256 reservesBefore = ofd.balanceOf(address(ofd.reserve())) - ofd.equity();\n        // revertWith(\"reserves before \", reservesBefore);  // 21000.000000000000000000\n        endChallenge(latestChallenge); // can be absorbed with equity\n        uint256 reservesAfter = ofd.balanceOf(address(ofd.reserve())) - ofd.equity();\n        require(reservesBefore - reservesAfter == 10000 ether); // latest challenge was 50'000 with 20% reserve\n        // revertWith(\"reserves before \", reservesAfter);  // 11000.000000000000000000\n        // revertWith(\"reserves before \", ofd.equity());     //  8601.000000000000000003\n        // splitAndEnd(latestChallenge - 1);\n    }\n\n    function endChallenge(uint256 challengeNumber) public {\n        uint256 equityBefore = ofd.equity();\n        (address challenger, uint40 start, IPosition p, uint256 size) = hub.challenges(challengeNumber);\n        require(challenger != address(0x0), \"challenge not found\");\n        // hub.end(challengeNumber, true);\n        User user = challenger == address(bob) ? bob : alice;\n        user.reclaimCollateral(hub, p.collateral(), size);\n\n        /*         uint256 borrowedAmount = 50000 * (10 ** 18);\n        uint256 reserve = (borrowedAmount * p.reserveContribution()) / 1000000;\n        uint256 reward = (bid * 20000) / 1000000;\n        uint256 missing = borrowedAmount + reward - bid - reserve;\n        uint256 equityAfter = ofd.equity();\n        uint256 assigned = ofd.calculateAssignedReserve(\n            1000000,\n            uint32(200000)\n        );\n        if (equityBefore >= missing) {\n            string memory message = string(\n                abi.encodePacked(\n                    Strings.toString(equityBefore),\n                    \" \",\n                    Strings.toString(equityAfter),\n                    \" \",\n                    Strings.toString(missing)\n                )\n            );\n            require(equityAfter + missing == equityBefore, message);\n        } else {\n            // revertWith(\"reserve \", assigned); // 50601000000000000000003\n            require(equityAfter == 0, Strings.toString(equityAfter)); // wiped out equity\n            require(\n                assigned == 0 ||\n                    ofd.calculateAssignedReserve(1000000, 200000) < assigned\n            );\n            // theoretical minter reserve at this point: 3000.000000000000000000, actual: 0\n        } */\n    }\n\n    uint256 number;\n\n    function testExcessiveChallengePart1() public {\n        // revertWith(\"reserve \", ofd.balanceOf(address(ofd.reserve()))); // 50601000000000000000003\n        Position pos = Position(latestPosition);\n        //uint256 minted = pos.minted();\n        //        require(minted == 10000 ether, Strings.toString(minted)); // assumes the other tests have been run before\n        uint256 collateralLeft = pos.collateral().balanceOf(latestPosition);\n        require(collateralLeft == 100, Strings.toString(collateralLeft)); // test assumption\n        number = bob.challenge(hub, latestPosition, 101); // challenge more than is left\n        //   alice.repay(pos, 5000 ether);\n        // require(pos.minted() + 5000 ether == minted);\n        // minted is now 9999.999999999999995000\n    }\n\n    function testExcessiveChallengePart2() public {\n        bob.avertChallenge(hub, swap, number);\n    }\n\n    function restructure() public {\n        address[] memory empty = new address[](0);\n        ofd.reserve().checkQualified(address(alice), empty);\n        ofd.reserve().checkQualified(address(bob), empty);\n        address[] memory list = new address[](1);\n        list[0] = address(bob);\n        Equity equity = Equity(address(ofd.reserve()));\n        uint256 totalVotes = equity.totalVotes();\n        uint256 supplyBefore = equity.totalSupply();\n        uint256 bobBefore = equity.balanceOf(address(bob));\n        alice.restructure(empty, list);\n        ofd.reserve().checkQualified(address(alice), empty);\n        require(equity.totalVotes() < totalVotes);\n        require(equity.balanceOf(address(bob)) == 0);\n        uint256 supplyAfter = equity.totalSupply();\n        require(supplyAfter == supplyBefore - bobBefore);\n        // revertWith(\"Shortfall: \", ofd.minterReserve() - ofd.balanceOf(address(ofd.reserve()))); // 1000000000000000000000\n        alice.obtainOracleFreeDollars(swap, 4000 ether);\n        alice.invest(4000 ether);\n        require(supplyAfter + 1000 ether == equity.totalSupply());\n    }\n\n    // poor man's replacement for console.out in solidity...\n    function revertWith(string memory message, uint256 errorNumber) public pure {\n        revert(string(abi.encodePacked(message, Strings.toString(errorNumber))));\n    }\n\n    function challengeExpiredPosition() public {\n        Position pos = Position(latestPosition);\n        require(pos.calculateCurrentFee() == 0);\n        require(pos.expiration() < block.timestamp);\n        uint256 size = pos.collateral().balanceOf(latestPosition);\n        latestChallenge = bob.challenge(hub, latestPosition, size);\n        // revertWith(\"col left \", size); // 100\n        bob.obtainOracleFreeDollars(swap, 5000 ether);\n    }\n\n    function endLastChallenge() public {\n        Position pos = Position(latestPosition);\n        // hub.end(latestChallenge, false);\n        require(pos.collateral().balanceOf(latestPosition) == 0);\n    }\n}\n\ncontract User {\n    IOracleFreeDollar ofd;\n\n    constructor(IOracleFreeDollar ofd_) {\n        ofd = ofd_;\n    }\n\n    function obtainOracleFreeDollars(StablecoinBridge bridge, uint256 amount) public {\n        TestToken usd = TestToken(address(bridge.usd()));\n        usd.mint(address(this), amount);\n        usd.approve(address(bridge), amount);\n        require(usd.allowance(address(this), address(bridge)) == amount);\n        bridge.mint(amount);\n    }\n\n    function invest(uint256 amount) public {\n        ofd.reserve().invest(amount, 0);\n    }\n\n    function transfer(IERC20 token, address target, uint256 amount) public {\n        token.transfer(target, amount);\n    }\n\n    function initiatePosition(TestToken col, MintingHub hub) public returns (address) {\n        col.mint(address(this), 1001);\n        col.approve(address(hub), 1001);\n        uint256 balanceBefore = ofd.balanceOf(address(this));\n        address pos = hub.openPosition(\n            address(col),\n            100,\n            1001,\n            1000000 ether,\n            7 days,\n            100 days,\n            1 days,\n            25000,\n            100 * (10 ** 36),\n            200000\n        );\n        require((balanceBefore - hub.OPENING_FEE()) == ofd.balanceOf(address(this)));\n        Position(pos).adjust(0, 1001, 200 * (10 ** 36));\n        Position(pos).adjustPrice(100 * (10 ** 36));\n        return pos;\n    }\n\n    function transferOwnership(address pos, address newOwner) public {\n        Position(pos).transferOwnership(newOwner);\n    }\n\n    function deny(MintingHub, address pos) public {\n        address[] memory empty = new address[](0);\n        Position(pos).deny(empty, \"not approved\");\n    }\n\n    function adjustPosition(address pos) public {\n        Position position = Position(pos);\n        uint256 minted = position.minted();\n        uint256 col = position.collateral().balanceOf(pos);\n        uint256 price = position.price();\n        position.adjust(minted - 100, col - 1, price);\n        position.collateral().approve(pos, 1);\n        position.adjust(minted, col, price);\n        require(position.minted() == minted);\n        require(position.collateral().balanceOf(pos) == col);\n        require(position.price() == price);\n    }\n\n    function repay(Position pos, uint256 amount) public {\n        uint256 balanceBefore = ofd.balanceOf(address(this));\n        require(balanceBefore >= amount);\n        pos.repay(amount);\n        require(ofd.balanceOf(address(this)) + amount == balanceBefore);\n    }\n\n    function testWithdraw(StablecoinBridge bridge, Position pos) public {\n        IERC20 col = pos.collateral();\n        obtainOracleFreeDollars(bridge, 1);\n        bridge.ofd().transfer(address(pos), 1);\n        uint256 initialBalance = col.balanceOf(address(pos));\n        pos.withdraw(address(bridge.ofd()), address(this), 1);\n        Position(pos).withdraw(address(col), address(this), 1);\n        require(col.balanceOf(address(pos)) == initialBalance - 1);\n        require(col.balanceOf(address(this)) == 1);\n    }\n\n    function mint(address pos, uint256 amount) public {\n        uint256 balanceBefore = ofd.balanceOf(address(this));\n        IPosition(pos).mint(address(this), amount);\n        uint256 obtained = ofd.balanceOf(address(this)) - balanceBefore;\n        uint256 usable = IPosition(pos).getUsableMint(amount, true);\n        require(\n            obtained == usable,\n            string(abi.encodePacked(Strings.toString(usable), \" should be \", Strings.toString(obtained)))\n        );\n        uint256 usableBeforeFee = IPosition(pos).getUsableMint(amount, false);\n        require(\n            usable <= 100 || usableBeforeFee > usable,\n            string(\n                abi.encodePacked(Strings.toString(usableBeforeFee), \" should be larger than \", Strings.toString(usable))\n            )\n        );\n    }\n\n    function challenge(MintingHub hub, address pos, uint256 size) public returns (uint256) {\n        IERC20 col = IPosition(pos).collateral();\n        col.approve(address(hub), size);\n        return hub.challenge(pos, size, IPosition(pos).price());\n    }\n\n    function avertChallenge(MintingHub hub, StablecoinBridge swap, uint256 first) public {\n        /* {\n            (, IPosition p, uint256 size, , , ) = hub.challenges(first);\n            uint256 amount = (size * p.price()) / 10 ** 18;\n            obtainOracleFreeDollars(swap, amount);\n            hub.bid(first, amount, size); // avert challenge\n        }\n        (address challenger, , , , , ) = hub.challenges(first);\n        require(challenger == address(0x0), \"challenge not averted\");\n        require(!hub.isChallengeOpen(first)); */\n    }\n\n    function bid(MintingHub hub, uint256 number, uint256 amount) public {\n        /*   (, , uint256 size, , , ) = hub.challenges(number);\n        hub.bid(number, amount, size);\n        require(hub.minBid(number) > amount); // min bid must increase */\n    }\n\n    function reclaimCollateral(MintingHub hub, IERC20 collateral, uint256 expectedAmount) public {\n        uint256 balanceBefore = collateral.balanceOf(address(this));\n        hub.returnPostponedCollateral(address(collateral), address(this));\n        uint256 balanceAfter = collateral.balanceOf(address(this));\n        require(balanceBefore + expectedAmount == balanceAfter);\n    }\n\n    function restructure(address[] calldata helpers, address[] calldata addressesToWipe) public {\n        Equity(address(ofd.reserve())).restructureCapTable(helpers, addressesToWipe);\n    }\n}\n"
    },
    "contracts/test/MockVOLToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/ERC20.sol\";\n\ncontract MockVOLToken is ERC20 {\n    constructor() ERC20(18) {\n        _mint(msg.sender, 1_000_000 * 1e18);\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"VOL volatile mock token\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"VOL\";\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        _mint(_account, _amount);\n    }\n}\n"
    },
    "contracts/test/PositionExpirationTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Strings.sol\";\nimport \"./TestToken.sol\";\nimport \"../Equity.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../Position.sol\";\nimport \"../MintingHub.sol\";\nimport \"../StablecoinBridge.sol\";\nimport \"../interface/IPosition.sol\";\nimport \"../interface/IReserve.sol\";\nimport \"../interface/IOracleFreeDollar.sol\";\nimport \"../interface/IERC20.sol\";\n\ncontract PositionExpirationTest {\n    MintingHub hub;\n    TestToken col;\n    IOracleFreeDollar ofd;\n\n    constructor(address hub_) {\n        hub = MintingHub(hub_);\n        col = new TestToken(\"Some Collateral\", \"COL\", uint8(0));\n        ofd = hub.ofd();\n    }\n\n    function openPositionFor(address owner) public returns (address) {\n        col.mint(address(this), 100);\n        col.approve(address(hub), 100);\n        address pos = hub.openPosition(address(col), 10, 100 /* collateral */, 1000000 * 10**18, 7 days, 30 days, 10 hours, 50000, 1000 * 10**36 /* price */, 200000);\n        Position(pos).transferOwnership(owner);\n        return pos;\n    }\n\n    function forceBuy(address pos, uint256 amount) public {\n        uint256 price = hub.expiredPurchasePrice(Position(pos));\n        uint256 balanceBefore = ofd.balanceOf(address(this));\n        uint256 colBalBefore = col.balanceOf(address(this));\n        hub.buyExpiredCollateral(Position(pos), amount);\n        uint256 balanceAfter = ofd.balanceOf(address(this));\n        uint256 colBalAfter = col.balanceOf(address(this));\n        require(colBalAfter - colBalBefore == amount, \"collateral amount\");\n        require((balanceBefore - balanceAfter) == amount * price / 10**18, \"price paid\");\n    }\n\n}\n"
    },
    "contracts/test/PositionRollingTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Strings.sol\";\nimport \"./TestToken.sol\";\nimport \"../Equity.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../Position.sol\";\nimport \"../MintingHub.sol\";\nimport \"../StablecoinBridge.sol\";\nimport \"../interface/IPosition.sol\";\nimport \"../interface/IReserve.sol\";\nimport \"../interface/IOracleFreeDollar.sol\";\nimport \"../interface/IERC20.sol\";\n\ncontract PositionRollingTest {\n\n    MintingHub hub;\n    TestToken col;\n    IOracleFreeDollar ofd;\n    PositionRoller roller;\n\n    IPosition public p1;\n    IPosition public p2;\n\n    constructor(address hub_) {\n        hub = MintingHub(hub_);\n        col = new TestToken(\"Some Collateral\", \"COL\", uint8(0));\n        ofd = hub.ofd();\n        roller = hub.roller();\n    }\n\n    function openTwoPositions() public {\n        p1 = IPosition(openPosition(100, uint40(3 days)));\n        p2 = IPosition(openPosition(10, uint40(7 days)));\n    }\n\n    function mintFromFirstPosition(uint256 amount) public {\n        p1.mint(address(this), amount);\n    }\n\n    function openPosition(uint256 collateral, uint40 initializationDelay) public returns (address) {\n        col.mint(address(this), collateral);\n        col.approve(address(hub), collateral);\n        return hub.openPosition(address(col), 10, collateral, 1000000 * 10**18, initializationDelay, 30 days, 10 hours, 50000, 1000 * 10**36, 200000);\n    }\n\n    function roll() public {\n        col.approve(address(roller), col.balanceOf(address(p1))); // approve full balance\n        roller.rollFully(p1, p2);\n        require(p1.minted() == 0);\n        require(ofd.balanceOf(address(this)) == 0);\n    }\n\n}\n"
    },
    "contracts/test/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}"
    },
    "contracts/test/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Math.sol\";\nimport \"./SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}"
    },
    "contracts/test/TestMathUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/MathUtil.sol\";\n\ncontract TestMathUtil is MathUtil {\n\n    uint256 public result;\n\n    constructor(){\n        result = 1;\n    }\n\n    // make it a transaction so we can measure gas costs in our tests\n    function cubicRoot(uint256 a, bool recordResult) external {\n        uint256 r = _cubicRoot(a); \n        if (recordResult){\n            result = r;\n        }\n    }\n\n    function calculateShares(uint256 totalShares, uint256 capitalBefore, uint256 investment) external pure returns (uint256) {\n        uint256 newTotalShares = _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investment, capitalBefore)));\n        return newTotalShares - totalShares;\n    }\n\n    function mulD18(uint256 _a, uint256 _b) external pure returns (uint256) {\n        return _mulD18(_a, _b);\n    }\n\n    function divD18(uint256 _a, uint256 _b) external pure returns (uint256) {\n        return _divD18(_a, _b);\n    }\n\n    function power3(uint256 _x) external pure returns (uint256) {\n        return _power3(_x);\n    }\n}\n"
    },
    "contracts/test/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    string public name;\n    string public symbol;\n\n    constructor(string memory name_, string memory symbol_, uint8 dec) ERC20(dec) {\n        name = name_;\n        symbol = symbol_;\n\n        _mint(msg.sender, 1_000_000 * 10 ** dec);\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        _mint(_account, _amount);\n    }\n}\n"
    },
    "contracts/utils/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied and adjusted from OpenZeppelin\n// Adjustments:\n// - modifications to support ERC-677\n// - removed require messages to save space\n// - removed unnecessary require statements\n// - removed GSN Context\n// - upgraded to 0.8 to drop SafeMath\n// - let name() and symbol() be implemented by subclass\n// - infinite allowance support, with 2^255 and above considered infinite\n\npragma solidity ^0.8.0;\n\nimport \"../interface/IERC20.sol\";\nimport \"../interface/IERC677Receiver.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n */\n\nabstract contract ERC20 is IERC20 {\n    mapping(address account => uint256 balance) private _balances;\n\n    mapping(address account => mapping(address spender => uint256 allowance)) private _allowances;\n\n    uint256 internal constant INFINITY = (1 << 255);\n\n    uint256 private _totalSupply;\n\n    uint8 public immutable override decimals;\n\n    // Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4139/files#diff-fa792f7d08644eebc519dac2c29b00a54afc4c6a76b9ef3bba56c8401fe674f6\n    // Indicates an error related to the current balance of a sender. Used in transfers.\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n    // Indicates a failure with the spender’s allowance. Used in transfers.\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    constructor(uint8 _decimals) {\n        decimals = _decimals;\n    }\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowance(owner, spender);\n    }\n\n    function _allowance(address owner, address spender) internal view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _useAllowance(sender, msg.sender, amount);\n        return true;\n    }\n\n    function _useAllowance(address owner, address spender, uint256 amount) internal {\n        uint256 currentAllowance = _allowance(owner, spender);\n        if (currentAllowance < INFINITY) {\n            // Only decrease the allowance if it was not set to 'infinite'\n            // Documented in github.com/aktionariat/contracts/blob/master/doc/infiniteallowance.md\n            if (currentAllowance < amount) revert ERC20InsufficientAllowance(owner, currentAllowance, amount);\n            _approve(owner, spender, currentAllowance - amount);\n        }\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n\n        _beforeTokenTransfer(sender, recipient, amount);\n        if (_balances[sender] < amount) revert ERC20InsufficientBalance(sender, _balances[sender], amount);\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n\n        _beforeTokenTransfer(address(0), recipient, amount);\n\n        _totalSupply += amount;\n        _balances[recipient] += amount;\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _totalSupply -= amount;\n        _balances[account] -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "contracts/utils/ERC20PermitLight.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract ERC20PermitLight is ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address account => uint256 nonce) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        unchecked {\n            // unchecked to save a little gas with the nonce increment...\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\n                                bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    //keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n                    bytes32(0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n}\n"
    },
    "contracts/utils/MathUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Functions for share valuation\n */\ncontract MathUtil {\n    uint256 internal constant ONE_DEC18 = 10 ** 18;\n\n    // Let's go for 12 digits of precision (18-6)\n    uint256 internal constant THRESH_DEC18 = 10 ** 6;\n\n    /**\n     * @notice Cubic root with Halley approximation\n     *         Number 1e18 decimal\n     * @param _v     number for which we calculate x**(1/3)\n     * @return returns _v**(1/3)\n     */\n    function _cubicRoot(uint256 _v) internal pure returns (uint256) {\n        // Good first guess for _v slightly above 1.0, which is often the case in the OracleFreeDollar system\n        uint256 x = _v > ONE_DEC18 && _v < 10 ** 19 ? (_v - ONE_DEC18) / 3 + ONE_DEC18 : ONE_DEC18;\n        uint256 diff;\n        do {\n            uint256 powX3 = _mulD18(_mulD18(x, x), x);\n            uint256 xnew = x * (powX3 + 2 * _v) / (2 * powX3 + _v);\n            diff = xnew > x ? xnew - x : x - xnew;\n            x = xnew;\n        } while (diff > THRESH_DEC18);\n        return x;\n    }\n\n    function _mulD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a * _b) / ONE_DEC18;\n    }\n\n    function _divD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a * ONE_DEC18) / _b;\n    }\n\n    function _power3(uint256 _x) internal pure returns (uint256) {\n        return _mulD18(_mulD18(_x, _x), _x);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/utils/OFDPSWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"./ERC20PermitLight.sol\";\nimport \"../Equity.sol\";\n\ncontract OFDPSWrapper is ERC20 {\n\n    Equity private immutable ofdps;\n\n    constructor(Equity ofdps_) ERC20(18){\n        ofdps = ofdps_;\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Wrapped OracleFreeDollar Pool Share\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"WOFDPS\";\n    }\n\n    // requires allowance\n    function wrap(uint256 amount) public {\n        depositFor(msg.sender, amount);\n    }\n\n    /**\n     * Same function as in openzeppelin ERC20Wrapper\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\n     */\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        ofdps.transferFrom(msg.sender, address(this), amount);\n        super._mint(account, amount);\n        return true;\n    }\n\n    function unwrap(uint256 amount) public {\n        withdrawTo(msg.sender, amount);\n    }\n\n    /**\n     * Same function as in openzeppelin ERC20Wrapper\n     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.\n     */\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        super._burn(msg.sender, amount);\n        ofdps.transfer(account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Returns the address of the underlying ERC-20 token that is being wrapped.\n     */\n    function underlying() public view returns (IERC20) {\n        return ofdps;\n    }\n\n    /**\n     * Sell immediately, bypassing the 90 day holding requirement if the\n     * average wrapped token has been around for long enough and no one\n     * cancelled the votes of this contract. Can help with market making\n     * between chains when this token is bridged.\n     *\n     * Anyone can prevent this method from being executable via the\n     * halveHoldingDuration function. Also, it won't be executable in an\n     * expanding market where the number of wrapped FPS doubles every\n     * 90 days such that the average holding period of this contract stays\n     * below that duration.\n     */\n    function unwrapAndSell(uint256 amount) public {\n        super._burn(msg.sender, amount);\n        ofdps.redeem(msg.sender, amount);\n    }\n\n    /**\n     * Reduces the recorded holding duration of the wrapped FPS. This has two effects:\n     * - Averts the risk of this contract accumulating too many votes over time (i.e. 98%)\n     * - Can prevent \"unwrapAndSell\" from succeeding (which can be desired to prevent short\n     *   term arbitrage at the cost of all other FPS holders)\n     *\n     * Anyone with 2% of the votes can call this.\n     */\n    function halveHoldingDuration(address[] calldata helpers) public {\n        ofdps.checkQualified(msg.sender, helpers);\n        // causes our votes to be cut in half\n        ofdps.transfer(address(this), totalSupply());\n    }\n\n}\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n//\n// Modifications:\n// - Replaced Context._msgSender() with msg.sender\n// - Made leaner\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n */\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    error NotOwner();\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _setOwner(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _setOwner(address newOwner) internal {\n        require(newOwner != address(0x0));\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    function _requireOwner(address sender) internal view {\n        if (owner != sender) revert NotOwner();\n    }\n\n    modifier onlyOwner() {\n        _requireOwner(msg.sender);\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}
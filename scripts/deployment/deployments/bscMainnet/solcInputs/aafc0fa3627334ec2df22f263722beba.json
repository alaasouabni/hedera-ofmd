{
  "language": "Solidity",
  "sources": {
    "contracts/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n *\n * Copyright (c) 2016-2019 zOS Global Limited\n *\n */\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns always true. Throws error on failure.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value can change when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns always true. Throws error on failure.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interface/IOracleFreeDollar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\n\ninterface IOracleFreeDollar is IERC20 {\n    function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) external;\n\n    function registerPosition(address position) external;\n\n    function denyMinter(address minter, address[] calldata helpers, string calldata message) external;\n\n    function reserve() external view returns (IReserve);\n\n    function minterReserve() external view returns (uint256);\n\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) external view returns (uint256);\n\n    function equity() external view returns (uint256);\n\n    function isMinter(address minter) external view returns (bool);\n\n    function getPositionParent(address position) external view returns (address);\n\n    function mint(address target, uint256 amount) external;\n\n    function mintWithReserve(address target, uint256 amount, uint32 reservePPM, uint32 feePPM) external;\n\n    function burnFrom(address target, uint256 amount) external;\n\n    function burnWithoutReserve(uint256 amountIncludingReserve, uint32 reservePPM) external;\n\n    function burnFromWithReserve(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external returns (uint256);\n\n    function burnWithReserve(uint256 amountExcludingReserve, uint32 reservePPM) external returns (uint256);\n\n    function coverLoss(address source, uint256 amount) external;\n\n    function collectProfits(address source, uint256 _amount) external;\n}\n"
    },
    "contracts/interface/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\nimport \"./IOracleFreeDollar.sol\";\n\ninterface IPosition {\n\n    function original() external returns (address);\n\n    function collateral() external returns (IERC20);\n\n    function minimumCollateral() external returns (uint256);\n\n    function challengePeriod() external returns (uint64);\n\n    function expiration() external returns (uint256);\n\n    function price() external returns (uint256);\n\n    function reduceLimitForClone(uint256 amount) external;\n\n    function initializeClone(address owner, uint256 _price, uint256 _coll, uint256 _mint, uint256 expiration) external;\n\n    function deny(address[] calldata helpers, string calldata message) external;\n\n    function mint(address target, uint256 amount) external;\n\n    function minted() external returns (uint256);\n\n    function reserveContribution() external returns (uint32);\n\n    function getUsableMint(uint256 totalMint, bool beforeFees) external view returns (uint256);\n\n    function challengeData(uint256 challengeStart) external view returns (uint256 liqPrice, uint64 phase1, uint64 phase2);\n\n    function notifyChallengeStarted(uint256 size) external;\n\n    function notifyChallengeAverted(uint256 size) external;\n\n    function notifyChallengeSucceeded(address _bidder, uint256 _size) external returns (address, uint256, uint256, uint32);\n\n}\n"
    },
    "contracts/interface/IReserve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\ninterface IReserve is IERC20 {\n   function invest(uint256 amount, uint256 expected) external returns (uint256);\n   function checkQualified(address sender, address[] calldata helpers) external view;\n}"
    },
    "contracts/Position.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./utils/Ownable.sol\";\nimport \"./utils/MathUtil.sol\";\n\nimport \"./interface/IERC20.sol\";\nimport \"./interface/IPosition.sol\";\nimport \"./interface/IReserve.sol\";\nimport \"./interface/IOracleFreeDollar.sol\";\n\n/**\n * @title Position\n * @notice A collateralized minting position.\n */\ncontract Position is Ownable, IPosition, MathUtil {\n    /**\n     * @notice Note that this contract is intended to be cloned. All clones will share the same values for\n     * the constant and immutable fields, but have their own values for the other fields.\n     */\n\n    /**\n     * @notice The ofd price per unit of the collateral below which challenges succeed, (36 - collateral.decimals) decimals\n     */\n    uint256 public price;\n\n    /**\n     * @notice Net minted amount, including reserve.\n     */\n    uint256 public minted;\n\n    /**\n     * @notice Amount of the collateral that is currently under a challenge.\n     * Used to figure out whether there are pending challenges.\n     */\n    uint256 public challengedAmount;\n\n    /**\n     * @notice Challenge period in seconds.\n     */\n    uint64 public immutable challengePeriod;\n\n    /**\n     * @notice End of the latest cooldown. If this is in the future, minting is suspended.\n     */\n    uint256 public cooldown;\n\n    /**\n     * @notice How much can be minted at most.\n     */\n    uint256 public limit;\n\n    /**\n     * @notice Timestamp when minting can start and the position no longer denied.\n     */\n    uint256 public immutable start;\n\n    /**\n     * @notice Timestamp of the expiration of the position. After expiration, challenges cannot be averted\n     * any more. This is also the basis for fee calculations.\n     */\n    uint256 public expiration;\n\n    /**\n     * @notice The original position to help identifying clones.\n     */\n    address public immutable original;\n\n    /**\n     * @notice Pointer to the minting hub.\n     */\n    address public immutable hub;\n\n    /**\n     * @notice The OracleFreeDollar contract.\n     */\n    IOracleFreeDollar public immutable ofd;\n\n    /**\n     * @notice The collateral token.\n     */\n    IERC20 public immutable override collateral;\n\n    /**\n     * @notice Minimum acceptable collateral amount to prevent dust.\n     */\n    uint256 public immutable override minimumCollateral;\n\n    /**\n     * @notice Always pay interest for at least four weeks.\n     */\n    uint256 private constant MIN_INTEREST_DURATION = 4 weeks;\n\n    /**\n     * @notice The interest in parts per million per year that is deducted when minting OracleFreeDollars.\n     * To be paid upfront.\n     */\n    uint32 public immutable annualInterestPPM;\n\n    /**\n     * @notice The reserve contribution in parts per million of the minted amount.\n     */\n    uint32 public immutable reserveContribution;\n\n    event MintingUpdate(uint256 collateral, uint256 price, uint256 minted, uint256 limit);\n    event PositionDenied(address indexed sender, string message); // emitted if closed by governance\n\n    error InsufficientCollateral();\n    error TooLate();\n    error RepaidTooMuch(uint256 excess);\n    error LimitExceeded();\n    error ChallengeTooSmall();\n    error Expired();\n    error Hot();\n    error Challenged();\n    error NotHub();\n\n    modifier alive() {\n        if (block.timestamp >= expiration) revert Expired();\n        _;\n    }\n\n    modifier noCooldown() {\n        if (block.timestamp <= cooldown) revert Hot();\n        _;\n    }\n\n    modifier noChallenge() {\n        if (challengedAmount > 0) revert Challenged();\n        _;\n    }\n\n    modifier onlyHub() {\n        if (msg.sender != address(hub)) revert NotHub();\n        _;\n    }\n\n    /**\n     * @dev See MintingHub.openPosition\n     */\n    constructor(\n        address _owner,\n        address _hub,\n        address _ofd,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint256 _initPeriod,\n        uint256 _duration,\n        uint64 _challengePeriod,\n        uint32 _annualInterestPPM,\n        uint256 _liqPrice,\n        uint32 _reservePPM\n    ) {\n        require(_initPeriod >= 3 days); // must be at least three days, recommended to use higher values\n        _setOwner(_owner);\n        original = address(this);\n        hub = _hub;\n        ofd = IOracleFreeDollar(_ofd);\n        collateral = IERC20(_collateral);\n        annualInterestPPM = _annualInterestPPM;\n        reserveContribution = _reservePPM;\n        minimumCollateral = _minCollateral;\n        challengePeriod = _challengePeriod;\n        start = block.timestamp + _initPeriod; // at least three days time to deny the position\n        cooldown = start;\n        expiration = start + _duration;\n        limit = _initialLimit;\n        _setPrice(_liqPrice);\n    }\n\n    /**\n     * @notice Method to initialize a freshly created clone. It is the responsibility of the creator to make sure this is only\n     * called once and to call reduceLimitForClone on the original position before initializing the clone.\n     */\n    function initializeClone(\n        address owner,\n        uint256 _price,\n        uint256 _coll,\n        uint256 _initialMint,\n        uint256 expirationTime\n    ) external onlyHub {\n        if (_coll < minimumCollateral) revert InsufficientCollateral();\n        uint256 impliedPrice = (_initialMint * ONE_DEC18) / _coll;\n        _initialMint = (impliedPrice * _coll) / ONE_DEC18; // to cancel potential rounding errors\n        if (impliedPrice > _price) revert InsufficientCollateral();\n        _setOwner(owner);\n        limit = _initialMint;\n        expiration = expirationTime;\n        _setPrice(impliedPrice);\n        _mint(owner, _initialMint, _coll);\n    }\n\n    function limitForClones() public view returns (uint256) {\n        uint256 backedLimit = (_collateralBalance() * price) / ONE_DEC18;\n        if (backedLimit >= limit) {\n            return 0;\n        } else {\n            // due to invariants, this is always below (limit - minted)\n            return limit - backedLimit;\n        }\n    }\n\n    /**\n     * @notice Adjust this position's limit to allow a clone to mint its own OracleFreeDollars.\n     * Invariant: global limit stays the same.\n     *\n     * Cloning a position is only allowed if the position is not challenged, not expired and not in cooldown.\n     */\n    function reduceLimitForClone(uint256 mint_) external noChallenge noCooldown alive onlyHub {\n        if (mint_ > limitForClones()) revert LimitExceeded();\n        limit -= mint_;\n    }\n\n    /**\n     * @notice Qualified pool share holders can call this method to immediately expire a freshly proposed position.\n     */\n    function deny(address[] calldata helpers, string calldata message) external {\n        if (block.timestamp >= start) revert TooLate();\n        IReserve(ofd.reserve()).checkQualified(msg.sender, helpers);\n        _close(); // since expiration is immutable, we put it under eternal cooldown\n        emit PositionDenied(msg.sender, message);\n    }\n\n    function _close() internal {\n        cooldown = type(uint256).max;\n    }\n\n    function isClosed() public view returns (bool) {\n        return cooldown == type(uint256).max;\n    }\n\n    /**\n     * @notice This is how much the minter can actually use when minting OFD, with the rest being used\n     * assigned to the minter reserve or (if applicable) fees.\n     */\n    function getUsableMint(uint256 totalMint, bool afterFees) external view returns (uint256) {\n        if (afterFees) {\n            return (totalMint * (1000_000 - reserveContribution - calculateCurrentFee())) / 1000_000;\n        } else {\n            return (totalMint * (1000_000 - reserveContribution)) / 1000_000;\n        }\n    }\n\n    /**\n     * @notice \"All in one\" function to adjust the outstanding amount of OFD, the collateral amount,\n     * and the price in one transaction.\n     */\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) external onlyOwner {\n        uint256 colbal = _collateralBalance();\n        if (newCollateral > colbal) {\n            collateral.transferFrom(msg.sender, address(this), newCollateral - colbal);\n        }\n        // Must be called after collateral deposit, but before withdrawal\n        if (newMinted < minted) {\n            ofd.burnFromWithReserve(msg.sender, minted - newMinted, reserveContribution);\n            minted = newMinted;\n        }\n        if (newCollateral < colbal) {\n            withdrawCollateral(msg.sender, colbal - newCollateral);\n        }\n        // Must be called after collateral withdrawal\n        if (newMinted > minted) {\n            mint(msg.sender, newMinted - minted);\n        }\n        if (newPrice != price) {\n            adjustPrice(newPrice);\n        }\n    }\n\n    /**\n     * @notice Allows the position owner to adjust the liquidation price as long as there is no pending challenge.\n     * Lowering the liquidation price can be done with immediate effect, given that there is enough collateral.\n     * Increasing the liquidation price triggers a cooldown period of 3 days, during which minting is suspended.\n     */\n    function adjustPrice(uint256 newPrice) public onlyOwner noChallenge {\n        if (newPrice > price) {\n            _restrictMinting(3 days);\n        } else {\n            _checkCollateral(_collateralBalance(), newPrice);\n        }\n        _setPrice(newPrice);\n        emit MintingUpdate(_collateralBalance(), price, minted, limit);\n    }\n\n    function _setPrice(uint256 newPrice) internal {\n        require(newPrice * minimumCollateral <= limit * ONE_DEC18); // sanity check\n        price = newPrice;\n    }\n\n    function _collateralBalance() internal view returns (uint256) {\n        return IERC20(collateral).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Mint OFD as long as there is no open challenge, the position is not subject to a cooldown,\n     * and there is sufficient collateral.\n     */\n    function mint(address target, uint256 amount) public onlyOwner noChallenge noCooldown alive {\n        _mint(target, amount, _collateralBalance());\n    }\n\n    function calculateCurrentFee() public view returns (uint32) {\n        uint256 exp = expiration;\n        uint256 time = block.timestamp < start ? start : block.timestamp;\n        uint256 timePassed = time >= exp - MIN_INTEREST_DURATION ? MIN_INTEREST_DURATION : exp - time;\n        // Time resolution is in the range of minutes for typical interest rates.\n        return uint32((timePassed * annualInterestPPM) / 365 days);\n    }\n\n    function _mint(address target, uint256 amount, uint256 collateral_) internal {\n        if (minted + amount > limit) revert LimitExceeded();\n        ofd.mintWithReserve(target, amount, reserveContribution, calculateCurrentFee());\n        minted += amount;\n\n        _checkCollateral(collateral_, price);\n        emit MintingUpdate(_collateralBalance(), price, minted, limit);\n    }\n\n    function _restrictMinting(uint256 period) internal {\n        uint256 horizon = block.timestamp + period;\n        if (horizon > cooldown) {\n            cooldown = horizon;\n        }\n    }\n\n    /**\n     * @notice Repay some OFD. If too much is repaid, the call fails.\n     * It is possible to repay while there are challenges, but the collateral is locked until all is clear again.\n     *\n     * The repaid amount should fulfill the following equation in order to close the position,\n     * i.e. bring the minted amount to 0:\n     * minted = amount + ofd.calculateAssignedReserve(amount, reservePPM)\n     *\n     * Under normal circumstances, this implies:\n     * amount = minted * (1000000 - reservePPM)\n     *\n     * E.g. if minted is 50 and reservePPM is 200000, it is necessary to repay 40 to be able to close the position.\n     */\n    function repay(uint256 amount) public {\n        IERC20(ofd).transferFrom(msg.sender, address(this), amount);\n        uint256 actuallyRepaid = IOracleFreeDollar(ofd).burnWithReserve(amount, reserveContribution);\n        _notifyRepaid(actuallyRepaid);\n        emit MintingUpdate(_collateralBalance(), price, minted, limit);\n    }\n\n    function _notifyRepaid(uint256 amount) internal {\n        if (amount > minted) revert RepaidTooMuch(amount - minted);\n        minted -= amount;\n    }\n\n    /**\n     * @notice Withdraw any ERC20 token that might have ended up on this address.\n     * Withdrawing collateral is subject to the same restrictions as withdrawCollateral(...).\n     */\n    function withdraw(address token, address target, uint256 amount) external onlyOwner {\n        if (token == address(collateral)) {\n            withdrawCollateral(target, amount);\n        } else {\n            uint256 balance = _collateralBalance();\n            IERC20(token).transfer(target, amount);\n            require(balance == _collateralBalance()); // guard against double-entry-point tokens\n        }\n    }\n\n    /**\n     * @notice Withdraw collateral from the position up to the extent that it is still well collateralized afterwards.\n     * Not possible as long as there is an open challenge or the contract is subject to a cooldown.\n     *\n     * Withdrawing collateral below the minimum collateral amount formally closes the position.\n     */\n    function withdrawCollateral(address target, uint256 amount) public onlyOwner noChallenge {\n        if (block.timestamp <= cooldown && !isClosed()) revert Hot();\n        uint256 balance = _withdrawCollateral(target, amount);\n        _checkCollateral(balance, price);\n        if (balance < minimumCollateral && balance > 0) revert InsufficientCollateral(); // Prevent dust amounts\n    }\n\n    function _withdrawCollateral(address target, uint256 amount) internal returns (uint256) {\n        if (amount > 0) {\n            // Some weird tokens fail when trying to transfer 0 amounts\n            IERC20(collateral).transfer(target, amount);\n        }\n        uint256 balance = _collateralBalance();\n        _considerClose(balance);\n        emit MintingUpdate(balance, price, minted, limit);\n        return balance;\n    }\n\n    function _considerClose(uint256 collateralBalance) internal {\n        if (collateralBalance < minimumCollateral && challengedAmount == 0) {\n            // This leaves a slightly unsatisfying possibility open: if the withdrawal happens due to a successful\n            // challenge, there might be a small amount of collateral left that is not withheld in case there are no\n            // other pending challenges. The only way to cleanly solve this would be to have two distinct cooldowns,\n            // one for minting and one for withdrawals.\n            _close();\n        }\n    }\n\n    /**\n     * @notice This invariant must always hold and must always be checked when any of the three\n     * variables change in an adverse way.\n     */\n    function _checkCollateral(uint256 collateralReserve, uint256 atPrice) internal view {\n        if (collateralReserve * atPrice < minted * ONE_DEC18) revert InsufficientCollateral();\n    }\n\n    /**\n     * @notice Returns the liquidation price and the durations for phase1 and phase2 of the challenge.\n     * Both phases are usually of equal duration, but near expiration, phase one is adjusted such that\n     * it cannot last beyond the expiration date of the position.\n     */\n    function challengeData(uint256 challengeStart) external view returns (uint256 liqPrice, uint64 phase1, uint64 phase2) {\n        uint256 timeToExpiration = challengeStart >= expiration ? 0 : expiration - challengeStart;\n        return (price, uint64(_min(timeToExpiration, challengePeriod)), challengePeriod);\n    }\n\n    function notifyChallengeStarted(uint256 size) external onlyHub {\n        // Require minimum size. Collateral balance can be below minimum if it was partially challenged before.\n        if (size < minimumCollateral && size < _collateralBalance()) revert ChallengeTooSmall();\n        if (size == 0) revert ChallengeTooSmall();\n        challengedAmount += size;\n    }\n\n    /**\n     * @param size   amount of collateral challenged (dec18)\n     */\n    function notifyChallengeAverted(uint256 size) external onlyHub {\n        challengedAmount -= size;\n\n        // Don't allow minter to close the position immediately so challenge can be repeated before\n        // the owner has a chance to mint more on an undercollateralized position\n        _restrictMinting(1 days);\n\n        // If this was the last open challenge and there is only a dust amount of collateral left, the position should be closed\n        _considerClose(_collateralBalance());\n    }\n\n    /**\n     * @notice Notifies the position that a challenge was successful.\n     * Triggers the payout of the challenged part of the collateral.\n     * Everything else is assumed to be handled by the hub.\n     *\n     * @param _bidder   address of the bidder that receives the collateral\n     * @param _size     amount of the collateral bid for\n     * @return (position owner, effective challenge size in OFD, amount to be repaid, reserve ppm)\n     */\n    function notifyChallengeSucceeded(\n        address _bidder,\n        uint256 _size\n    ) external onlyHub returns (address, uint256, uint256, uint32) {\n        challengedAmount -= _size;\n        uint256 colBal = _collateralBalance();\n        if (colBal < _size) {\n            _size = colBal;\n        }\n        uint256 repayment = colBal == 0 ? 0 : minted * _size / colBal; // for enormous colBal, this could be rounded to 0, which is ok\n        _notifyRepaid(repayment); // we assume the caller takes care of the actual repayment\n\n        // Give time for additional challenges before the owner can mint again. In particular,\n        // the owner might have added collateral only seconds before the challenge ended, preventing a close.\n        _restrictMinting(3 days);\n\n        _withdrawCollateral(_bidder, _size); // transfer collateral to the bidder and emit update\n\n        return (owner, _size, repayment, reserveContribution);\n    }\n}\n"
    },
    "contracts/utils/MathUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Functions for share valuation\n */\ncontract MathUtil {\n    uint256 internal constant ONE_DEC18 = 10 ** 18;\n\n    // Let's go for 12 digits of precision (18-6)\n    uint256 internal constant THRESH_DEC18 = 10 ** 6;\n\n    /**\n     * @notice Cubic root with Halley approximation\n     *         Number 1e18 decimal\n     * @param _v     number for which we calculate x**(1/3)\n     * @return returns _v**(1/3)\n     */\n    function _cubicRoot(uint256 _v) internal pure returns (uint256) {\n        // Good first guess for _v slightly above 1.0, which is often the case in the OracleFreeDollar system\n        uint256 x = _v > ONE_DEC18 && _v < 10 ** 19 ? (_v - ONE_DEC18) / 3 + ONE_DEC18 : ONE_DEC18;\n        uint256 diff;\n        do {\n            uint256 powX3 = _mulD18(_mulD18(x, x), x);\n            uint256 xnew = x * (powX3 + 2 * _v) / (2 * powX3 + _v);\n            diff = xnew > x ? xnew - x : x - xnew;\n            x = xnew;\n        } while (diff > THRESH_DEC18);\n        return x;\n    }\n\n    function _mulD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a * _b) / ONE_DEC18;\n    }\n\n    function _divD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a * ONE_DEC18) / _b;\n    }\n\n    function _power3(uint256 _x) internal pure returns (uint256) {\n        return _mulD18(_mulD18(_x, _x), _x);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n//\n// Modifications:\n// - Replaced Context._msgSender() with msg.sender\n// - Made leaner\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n */\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    error NotOwner();\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _setOwner(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _setOwner(address newOwner) internal {\n        require(newOwner != address(0x0));\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    function _requireOwner(address sender) internal view {\n        if (owner != sender) revert NotOwner();\n    }\n\n    modifier onlyOwner() {\n        _requireOwner(msg.sender);\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}
